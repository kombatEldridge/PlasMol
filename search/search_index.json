{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PlasMol Documentation PlasMol is a Python-based simulation framework for combining plasmonics (via Meep) with real-time time-dependent density functional theory (RT-TDDFT) simulations. It enables hybrid simulations of electromagnetic fields interacting with quantum molecular systems, useful for applications in plasmon-enhanced spectroscopy, nanophotonics, and quantum chemistry. Key Features Simulation Modes : Pure Meep (electromagnetics), pure RT-TDDFT (quantum), or hybrid PlasMol. Quantum Components : Molecule handling with PySCF, electric field interactions, density matrix propagation (step, magnus2, rk4 methods), checkpointing, and HOMO-LUMO analysis. Meep Integration : Custom sources (continuous, Gaussian, chirped, pulse), symmetries, PML boundaries, and HDF5 output for visualizations. Utilities : CSV handling for fields, Fourier transforms for spectra, plotting (e.g., electric vs. polarization fields), GIF generation, and logging. Input Handling : CLI arguments, input file parsing (Meep and Quantum sections), parameter merging. Quick Start Install dependencies: pip install pyscf meep numpy matplotlib pandas scipy . Run a simulation: python -m src.main -f path/to/input.in -v . For more, see Installation and Usage . Project Structure src/ : Core codebase with modular directories (drivers/, quantum/, meep/, input/, utils/). Organized for scalability, with relative imports and package __init__.py files. [TODO: Add project logo or screenshot of a simulation output here.]","title":"Home"},{"location":"#welcome-to-plasmol-documentation","text":"PlasMol is a Python-based simulation framework for combining plasmonics (via Meep) with real-time time-dependent density functional theory (RT-TDDFT) simulations. It enables hybrid simulations of electromagnetic fields interacting with quantum molecular systems, useful for applications in plasmon-enhanced spectroscopy, nanophotonics, and quantum chemistry.","title":"Welcome to PlasMol Documentation"},{"location":"#key-features","text":"Simulation Modes : Pure Meep (electromagnetics), pure RT-TDDFT (quantum), or hybrid PlasMol. Quantum Components : Molecule handling with PySCF, electric field interactions, density matrix propagation (step, magnus2, rk4 methods), checkpointing, and HOMO-LUMO analysis. Meep Integration : Custom sources (continuous, Gaussian, chirped, pulse), symmetries, PML boundaries, and HDF5 output for visualizations. Utilities : CSV handling for fields, Fourier transforms for spectra, plotting (e.g., electric vs. polarization fields), GIF generation, and logging. Input Handling : CLI arguments, input file parsing (Meep and Quantum sections), parameter merging.","title":"Key Features"},{"location":"#quick-start","text":"Install dependencies: pip install pyscf meep numpy matplotlib pandas scipy . Run a simulation: python -m src.main -f path/to/input.in -v . For more, see Installation and Usage .","title":"Quick Start"},{"location":"#project-structure","text":"src/ : Core codebase with modular directories (drivers/, quantum/, meep/, input/, utils/). Organized for scalability, with relative imports and package __init__.py files. [TODO: Add project logo or screenshot of a simulation output here.]","title":"Project Structure"},{"location":"about/","text":"About PlasMol PlasMol is developed for simulating plasmon-molecule interactions, blending classical FDTD with quantum RT-TDDFT. Releases v1.0.0 : Initial release containing three main capabilities based on contents of the input file: Input contains Nanoparticle (NP) Only : The team behind Meep have built a fantastic codebase with powerful FDTD-based outcomes. When given only parameters surrounding the simulation of a NP, PlasMol acts as a wrapper to Meep, allowing for the simulation of one NP object at a time. As it is the basis of the FDTD implementation for PlasMol, we recommend users visit and use Meep directly, but this is an option in PlasMol for those who want to compare other PlasMol (NP + Molecule) results to an isolated NP simulation. By default, this option only produces real time images of the NP interacting with an electric field. By adding other input flags (described in the docs), PlasMol will track and produce a cross-section extinction spectrum of the NP. Commented sections in the codebase direct users to modify/add functions to track other desired outcomes. Input contains Molecule Only : For inputs with only molecule-based parameters, PlasMol will run a Real-Time Time Dependent Density Functional Theory (RT-TDDFT) simulation. Though more details can be found in the docs, briefly, without any NP present, PlasMol will track the electric field felt by the molecule and the induced dipole moment of the molecule. With some additional flags, PlasMol can produce an absorption spectrum of the molecule. Input contains NP and Molecule : This is the main purpose of PlasMol. A Meep simulation will begin with a molecule inside, whose initial electronic structure is built by PySCF. Every time step, the electric field at the molecule's position is measured and sent to the \"quantum\" portion of the code where the density matrix is propagated by the electric field. As an end result, the induced dipole moment of the molecule can be calculated. Finally, the induced dipole moment is fed back into the Meep simulation as the intensity of a point dipole at the position of the molecule. Call For Contributions (as of July 22nd, 2025) This project has been a stepping stone for me in developing my expertise in modern quantum chemistry and computational methods. That being said, when I began work on PlasMol, I had loftier plans than just posting a minimal working version on GitHub, but plans and priorities change. As of the release of v1.0.0, work has paused on this project. For students in the same or adjacent fields, perhaps the PlasMol skeleton can inspire you to pick it up for your lab's specific desired outcomes. As is the nature of DFT work, one can track many things as a NP + Molecule simulation propagates by contracting the corresponding operator with the current density matrix. Empty commented sections are left in certain files to make adding custom functions easier. Particular work on monitoring SERS enhancements could put this code to great use, especially given that this was the original intention of the code. Citation There is no publication on this work presently. If I don't get around to getting a publication on this work before you want to use/modify it, please just drop a link in your work to the project's GitHub . License GPL-3.0 license Acknowledgments Libraries: Meep , PySCF , NumPy . Contributors: Brinton Eldridge . Advisors: Dr. Daniel Nascimento , Dr. Yongmei Wang . Contact Information Brinton Eldridge Email: bldrdge1@memphis.edu GitHub: https://github.com/kombatEldridge Organization: University of Memphis LinkedIn: https://www.linkedin.com/in/brinton-eldridge/","title":"About"},{"location":"about/#about-plasmol","text":"PlasMol is developed for simulating plasmon-molecule interactions, blending classical FDTD with quantum RT-TDDFT.","title":"About PlasMol"},{"location":"about/#releases","text":"v1.0.0 : Initial release containing three main capabilities based on contents of the input file: Input contains Nanoparticle (NP) Only : The team behind Meep have built a fantastic codebase with powerful FDTD-based outcomes. When given only parameters surrounding the simulation of a NP, PlasMol acts as a wrapper to Meep, allowing for the simulation of one NP object at a time. As it is the basis of the FDTD implementation for PlasMol, we recommend users visit and use Meep directly, but this is an option in PlasMol for those who want to compare other PlasMol (NP + Molecule) results to an isolated NP simulation. By default, this option only produces real time images of the NP interacting with an electric field. By adding other input flags (described in the docs), PlasMol will track and produce a cross-section extinction spectrum of the NP. Commented sections in the codebase direct users to modify/add functions to track other desired outcomes. Input contains Molecule Only : For inputs with only molecule-based parameters, PlasMol will run a Real-Time Time Dependent Density Functional Theory (RT-TDDFT) simulation. Though more details can be found in the docs, briefly, without any NP present, PlasMol will track the electric field felt by the molecule and the induced dipole moment of the molecule. With some additional flags, PlasMol can produce an absorption spectrum of the molecule. Input contains NP and Molecule : This is the main purpose of PlasMol. A Meep simulation will begin with a molecule inside, whose initial electronic structure is built by PySCF. Every time step, the electric field at the molecule's position is measured and sent to the \"quantum\" portion of the code where the density matrix is propagated by the electric field. As an end result, the induced dipole moment of the molecule can be calculated. Finally, the induced dipole moment is fed back into the Meep simulation as the intensity of a point dipole at the position of the molecule.","title":"Releases"},{"location":"about/#call-for-contributions","text":"(as of July 22nd, 2025) This project has been a stepping stone for me in developing my expertise in modern quantum chemistry and computational methods. That being said, when I began work on PlasMol, I had loftier plans than just posting a minimal working version on GitHub, but plans and priorities change. As of the release of v1.0.0, work has paused on this project. For students in the same or adjacent fields, perhaps the PlasMol skeleton can inspire you to pick it up for your lab's specific desired outcomes. As is the nature of DFT work, one can track many things as a NP + Molecule simulation propagates by contracting the corresponding operator with the current density matrix. Empty commented sections are left in certain files to make adding custom functions easier. Particular work on monitoring SERS enhancements could put this code to great use, especially given that this was the original intention of the code.","title":"Call For Contributions"},{"location":"about/#citation","text":"There is no publication on this work presently. If I don't get around to getting a publication on this work before you want to use/modify it, please just drop a link in your work to the project's GitHub .","title":"Citation"},{"location":"about/#license","text":"GPL-3.0 license","title":"License"},{"location":"about/#acknowledgments","text":"Libraries: Meep , PySCF , NumPy . Contributors: Brinton Eldridge . Advisors: Dr. Daniel Nascimento , Dr. Yongmei Wang .","title":"Acknowledgments"},{"location":"about/#contact-information","text":"Brinton Eldridge Email: bldrdge1@memphis.edu GitHub: https://github.com/kombatEldridge Organization: University of Memphis LinkedIn: https://www.linkedin.com/in/brinton-eldridge/","title":"Contact Information"},{"location":"api-reference/","text":"API Reference This page documents key classes and methods. Directory Tree | |_ docs | |_ *files for these docs* | |_ src | |_ __init__.py | |_ constants.py | |_ main.py | | | |_ classical | | |_ __init__.py | | |_ simulation.py | | |_ sources.py | | | |_ drivers | | |_ __init__.py | | |_ classical.py | | |_ plasmol.py | | |_ quantum.py | | | |_ input | | |_ __init__.py | | |_ cli.py | | |_ params.py | | |_ parser.py | | | |_ quantum | | |_ __init__.py | | |_ chkfile.py | | |_ electric_field.py | | |_ molecule.py | | |_ propagation.py | | | | | |_ propagators | | |_ __init__.py | | |_ magnus2.py | | |_ rk4.py | | |_ step.py | | | |_ utils | | |_ __init__.py | | |_ csv.py | | |_ fourier.py | | |_ gif.py | | |_ logging.py | | |_ plotting.py | |_ templates |_ template-classical.in |_ template-plasmol.in |_ template-quantum.in quantum/ molecule.py Initializes molecule with PySCF, handles SCF, Fock matrix, dipole calculations. Additional methods can be injected at the bottom of this class to track other quantum properties. For example, we track the induced dipole using the calculate_mu() method and then inject the call to this method in the quantum/propagation.py file. electric_field.py Builds electric fields (pulse or kick shapes) for the molecule to feel only when a quantum simulation is chosen. If classical or full PlasMol simulation is running, the electric field is generated inside the Meep simulation (using classical/sources.py ). Other electric field shapes for quantum simulations can be added to the build_field() method using the other two shapes as templates. quantum/propagators/ step.py Propagates molecular orbitals using the Magnus step method. This method is also known as the modified midpoint unitary transformation (MMUT) scheme from https://doi.org/10.1039/B415849K \\[ \\begin{gathered} \\mathbf{F}_{\\text {orth }}=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}, \\vec{\\mathbf{E}}\\right)\\\\ \\mathbf{U} =\\exp \\left(-2 i \\Delta t \\cdot \\mathbf{F}_{\\text {orth}} (t)\\right)\\\\ \\mathbf{C}_{\\text{ortho}} \\left(t + \\Delta t\\right)= \\mathbf{U} \\mathbf{C}_{\\text{ortho}} \\left(t - \\Delta t\\right) \\end{gathered} \\] rk4.py Propagates molecular orbitals using the Runge-Kutta 4 method. \\[ \\begin{gathered} \\mathbf{F}_{\\text {orth }}=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}, \\vec{\\mathbf{E}}\\right)\\\\ k _1=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth }} \\\\ \\mathbf{C}_{\\text {orth, } 1}= \\mathbf{C}_{\\text {orth }}+\\frac{1}{2} k _1 \\\\ k _2=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 1} \\\\ \\mathbf{C}_{\\text {orth, } 2}= \\mathbf{C}_{\\text {orth }}+\\frac{1}{2} k _2 \\\\ k _3=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 2} \\\\ \\mathbf{C}_{\\text {orth, } 3}= \\mathbf{C}_{\\text {orth }}+ k _3 \\\\ k _4=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 3} \\\\ \\mathbf{C}_{\\text {orth }}(t+\\Delta t)= \\mathbf{C}_{\\text {orth }}+\\frac{ k _1}{6}+\\frac{ k _2}{3}+\\frac{ k _3}{3}+\\frac{ k _4}{6} \\end{gathered} \\] magnus2.py Propagates molecular orbitals using the second order Magnus method with a predictor-corrector algorithm included. This method is described in many RT-TDDFT papers, but I found the derivation from https://doi.org/10.1021/ct501078d to be very understandable. \\[ \\mathbf{F}_{\\text{orth }}^{(0)}(t+\\Delta t / 2)=2 \\mathbf{F}_{\\text{orth }}(t)- \\mathbf{F}_{\\text{orth }}(t-\\Delta t / 2) \\] Then, for iterations \\(k=0,1,2, \\ldots\\) until convergence or maximum iterations exceeded: \\[ \\begin{gathered} \\mathbf{U}^{(k)}=\\exp \\left(-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }}^{(k)}(t+\\Delta t / 2)\\right) \\\\ \\mathbf{C}_{\\text {orth }}^{(k+1)}(t+\\Delta t)= \\mathbf{U}^{(k)} \\mathbf{C}_{\\text {orth }}(t) \\\\ \\mathbf{C}^{(k+1)}(t+\\Delta t)=\\text {molecule.rotate_coeff_away_from_orth}\\left( \\mathbf{C}_{\\text {orth }}^{(k+1)}(t+\\Delta t)\\right) \\\\ \\mathbf{D}_{\\text {AO }}^{(k+1)}(t+\\Delta t)=\\text {molecule.make_rdm1}\\left( \\mathbf{C}^{(k+1)}(t+\\Delta t), \\text { occ }\\right) \\\\ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t)=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}^{(k+1)}(t+\\Delta t), \\vec{\\mathbf{E}}\\right) \\end{gathered} \\] Update the midpoint guess for the next iteration: \\[ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t / 2)=\\frac{1}{2}\\left( \\mathbf{F}_{\\text {orth }}(t)+ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t)\\right) \\] Convergence is checked starting from the second iteration ( \\(k \\geq 1\\) ) as: \\[ \\left\\| \\mathbf{C}^{(k+1)}(t+\\Delta t)- \\mathbf{C}^{(k)}(t+\\Delta t)\\right\\|<\\epsilon \\] where \\(\\epsilon=\\) params.pc_convergence . Upon convergence, assign the final values to the molecule object: \\[ \\begin{gathered} \\mathbf{C}(t+\\Delta t)= \\mathbf{C}^{(\\text {final})}(t+\\Delta t), \\quad \\mathbf{D} _{\\text{AO}}(t+\\Delta t)= \\mathbf{D} _{\\text{AO}}^{(\\text {final})}(t+\\Delta t) \\\\ \\mathbf{F}_{\\text {orth }}(t+\\Delta t)= \\mathbf{F}_{\\text {orth }}^{(\\text {final})}(t+\\Delta t), \\quad \\mathbf{F}_{\\text {orth }}(t+\\Delta t / 2)= \\mathbf{F}_{\\text {orth }}^{(\\text {final})}(t+\\Delta t / 2) \\end{gathered} \\] The updated \\(\\mathbf{F}_{\\text{orth }}(t+\\Delta t / 2)\\) is stored for extrapolation in the next time step. classical/ simulation.py Runs Meep and full PlasMol simulation, handles sources, PML, symmetries. For those who want to add tracking to certain parameters, a commented section can be found in the run() method and right above it. An example code block is added (but commented out) to the run() method to graph the 3D model of the NP. sources.py Currently supports ContinuousSource The ContinuousSource provides a continuous-wave electromagnetic source with constant frequency and amplitude that activates abruptly at the start time and persists until the optional end time. $$ s(t)=\\theta\\left(t-t_{\\text {start}}\\right) \\exp (-i \\omega t) $$ where \\(\\theta\\) is the Heaviside step function, \\(t_{\\text {start}}\\) is the start time (default 0 ), and \\(\\omega=2 \\pi f\\) with \\(f\\) being the specified frequency. GaussianSource The GaussianSource generates a pulsed electromagnetic source with a Gaussian temporal envelope modulating a carrier wave, designed for broadband frequency excitation while minimizing truncation effects through a shifted peak. $$ s(t)=\\exp \\left(-\\frac{\\left(t-t_0\\right)^2}{2 w^2}\\right) \\exp (-i \\omega t) $$ where \\(w\\) is the width parameter, \\(t_0=t_{\\text {start}}+c \\cdot w\\) with \\(c\\) being the cutoff (default 5.0) to shift the peak and avoid abrupt truncation at \\(t=t_{\\text {start}}\\) , and \\(\\omega=2 \\pi f\\) with \\(f\\) being the center frequency. ChirpedSource The ChirpedSource is a custom pulsed source featuring a Gaussian envelope with an added quadratic phase term to produce a linearly chirped frequency sweep, useful for applications requiring timevarying frequency content. $$ s(t)=\\exp \\left(i 2 \\pi f\\left(t-t_p\\right)\\right) \\exp \\left(-a\\left(t-t_p\\right)^2+i b\\left(t-t_p\\right)^2\\right) $$ where \\(f\\) is the base frequency, \\(t_p\\) is the peak time, \\(a\\) is the width parameter controlling the envelope decay, and \\(b\\) is the chirp rate introducing quadratic phase for frequency modulation. PulseSource When simulating an absorption spectrum, this source is required. The PulseSource creates a custom Gaussian-enveloped pulse with a sinusoidal carrier wave peaked at a specified time, suitable for simulating short electromagnetic bursts in time-domain simulations. $$ s(t)=\\exp \\left(i 2 \\pi f\\left(t-t_p\\right)\\right) \\exp \\left(-a\\left(t-t_p\\right)^2\\right) $$ where \\(f\\) is the carrier frequency, \\(t_p\\) is the peak time, and \\(a\\) is the width parameter determining the pulse duration. Other electric field shapes for quantum simulations can be supported using the other two shapes as templates, but additional options for the sources will need to be added to the input file parser in the input/params.py file under the getSource() method (found in the buildclassicalParams() method). drivers/ classical.py Runs Meep simulation. quantum.py Runs RT-TDDFT, supports multi-threading for transforms. plasmol.py Hybrid run. utils/ utils.csv.initCSV(filename, comment) , updateCSV(...) . utils.plotting.show_eField_pField(eFieldFile, pFieldFile) . utils.fourier.transform(...) : Fourier transform and absorption spectrum. [TODO: Add full parameter lists, return types, or use Sphinx for auto-gen docs.]","title":"API Reference"},{"location":"api-reference/#api-reference","text":"This page documents key classes and methods.","title":"API Reference"},{"location":"api-reference/#directory-tree","text":"| |_ docs | |_ *files for these docs* | |_ src | |_ __init__.py | |_ constants.py | |_ main.py | | | |_ classical | | |_ __init__.py | | |_ simulation.py | | |_ sources.py | | | |_ drivers | | |_ __init__.py | | |_ classical.py | | |_ plasmol.py | | |_ quantum.py | | | |_ input | | |_ __init__.py | | |_ cli.py | | |_ params.py | | |_ parser.py | | | |_ quantum | | |_ __init__.py | | |_ chkfile.py | | |_ electric_field.py | | |_ molecule.py | | |_ propagation.py | | | | | |_ propagators | | |_ __init__.py | | |_ magnus2.py | | |_ rk4.py | | |_ step.py | | | |_ utils | | |_ __init__.py | | |_ csv.py | | |_ fourier.py | | |_ gif.py | | |_ logging.py | | |_ plotting.py | |_ templates |_ template-classical.in |_ template-plasmol.in |_ template-quantum.in","title":"Directory Tree"},{"location":"api-reference/#quantum","text":"","title":"quantum/"},{"location":"api-reference/#moleculepy","text":"Initializes molecule with PySCF, handles SCF, Fock matrix, dipole calculations. Additional methods can be injected at the bottom of this class to track other quantum properties. For example, we track the induced dipole using the calculate_mu() method and then inject the call to this method in the quantum/propagation.py file.","title":"molecule.py"},{"location":"api-reference/#electric_fieldpy","text":"Builds electric fields (pulse or kick shapes) for the molecule to feel only when a quantum simulation is chosen. If classical or full PlasMol simulation is running, the electric field is generated inside the Meep simulation (using classical/sources.py ). Other electric field shapes for quantum simulations can be added to the build_field() method using the other two shapes as templates.","title":"electric_field.py"},{"location":"api-reference/#quantumpropagators","text":"","title":"quantum/propagators/"},{"location":"api-reference/#steppy","text":"Propagates molecular orbitals using the Magnus step method. This method is also known as the modified midpoint unitary transformation (MMUT) scheme from https://doi.org/10.1039/B415849K \\[ \\begin{gathered} \\mathbf{F}_{\\text {orth }}=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}, \\vec{\\mathbf{E}}\\right)\\\\ \\mathbf{U} =\\exp \\left(-2 i \\Delta t \\cdot \\mathbf{F}_{\\text {orth}} (t)\\right)\\\\ \\mathbf{C}_{\\text{ortho}} \\left(t + \\Delta t\\right)= \\mathbf{U} \\mathbf{C}_{\\text{ortho}} \\left(t - \\Delta t\\right) \\end{gathered} \\]","title":"step.py"},{"location":"api-reference/#rk4py","text":"Propagates molecular orbitals using the Runge-Kutta 4 method. \\[ \\begin{gathered} \\mathbf{F}_{\\text {orth }}=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}, \\vec{\\mathbf{E}}\\right)\\\\ k _1=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth }} \\\\ \\mathbf{C}_{\\text {orth, } 1}= \\mathbf{C}_{\\text {orth }}+\\frac{1}{2} k _1 \\\\ k _2=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 1} \\\\ \\mathbf{C}_{\\text {orth, } 2}= \\mathbf{C}_{\\text {orth }}+\\frac{1}{2} k _2 \\\\ k _3=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 2} \\\\ \\mathbf{C}_{\\text {orth, } 3}= \\mathbf{C}_{\\text {orth }}+ k _3 \\\\ k _4=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 3} \\\\ \\mathbf{C}_{\\text {orth }}(t+\\Delta t)= \\mathbf{C}_{\\text {orth }}+\\frac{ k _1}{6}+\\frac{ k _2}{3}+\\frac{ k _3}{3}+\\frac{ k _4}{6} \\end{gathered} \\]","title":"rk4.py"},{"location":"api-reference/#magnus2py","text":"Propagates molecular orbitals using the second order Magnus method with a predictor-corrector algorithm included. This method is described in many RT-TDDFT papers, but I found the derivation from https://doi.org/10.1021/ct501078d to be very understandable. \\[ \\mathbf{F}_{\\text{orth }}^{(0)}(t+\\Delta t / 2)=2 \\mathbf{F}_{\\text{orth }}(t)- \\mathbf{F}_{\\text{orth }}(t-\\Delta t / 2) \\] Then, for iterations \\(k=0,1,2, \\ldots\\) until convergence or maximum iterations exceeded: \\[ \\begin{gathered} \\mathbf{U}^{(k)}=\\exp \\left(-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }}^{(k)}(t+\\Delta t / 2)\\right) \\\\ \\mathbf{C}_{\\text {orth }}^{(k+1)}(t+\\Delta t)= \\mathbf{U}^{(k)} \\mathbf{C}_{\\text {orth }}(t) \\\\ \\mathbf{C}^{(k+1)}(t+\\Delta t)=\\text {molecule.rotate_coeff_away_from_orth}\\left( \\mathbf{C}_{\\text {orth }}^{(k+1)}(t+\\Delta t)\\right) \\\\ \\mathbf{D}_{\\text {AO }}^{(k+1)}(t+\\Delta t)=\\text {molecule.make_rdm1}\\left( \\mathbf{C}^{(k+1)}(t+\\Delta t), \\text { occ }\\right) \\\\ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t)=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}^{(k+1)}(t+\\Delta t), \\vec{\\mathbf{E}}\\right) \\end{gathered} \\] Update the midpoint guess for the next iteration: \\[ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t / 2)=\\frac{1}{2}\\left( \\mathbf{F}_{\\text {orth }}(t)+ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t)\\right) \\] Convergence is checked starting from the second iteration ( \\(k \\geq 1\\) ) as: \\[ \\left\\| \\mathbf{C}^{(k+1)}(t+\\Delta t)- \\mathbf{C}^{(k)}(t+\\Delta t)\\right\\|<\\epsilon \\] where \\(\\epsilon=\\) params.pc_convergence . Upon convergence, assign the final values to the molecule object: \\[ \\begin{gathered} \\mathbf{C}(t+\\Delta t)= \\mathbf{C}^{(\\text {final})}(t+\\Delta t), \\quad \\mathbf{D} _{\\text{AO}}(t+\\Delta t)= \\mathbf{D} _{\\text{AO}}^{(\\text {final})}(t+\\Delta t) \\\\ \\mathbf{F}_{\\text {orth }}(t+\\Delta t)= \\mathbf{F}_{\\text {orth }}^{(\\text {final})}(t+\\Delta t), \\quad \\mathbf{F}_{\\text {orth }}(t+\\Delta t / 2)= \\mathbf{F}_{\\text {orth }}^{(\\text {final})}(t+\\Delta t / 2) \\end{gathered} \\] The updated \\(\\mathbf{F}_{\\text{orth }}(t+\\Delta t / 2)\\) is stored for extrapolation in the next time step.","title":"magnus2.py"},{"location":"api-reference/#classical","text":"","title":"classical/"},{"location":"api-reference/#simulationpy","text":"Runs Meep and full PlasMol simulation, handles sources, PML, symmetries. For those who want to add tracking to certain parameters, a commented section can be found in the run() method and right above it. An example code block is added (but commented out) to the run() method to graph the 3D model of the NP.","title":"simulation.py"},{"location":"api-reference/#sourcespy","text":"Currently supports ContinuousSource The ContinuousSource provides a continuous-wave electromagnetic source with constant frequency and amplitude that activates abruptly at the start time and persists until the optional end time. $$ s(t)=\\theta\\left(t-t_{\\text {start}}\\right) \\exp (-i \\omega t) $$ where \\(\\theta\\) is the Heaviside step function, \\(t_{\\text {start}}\\) is the start time (default 0 ), and \\(\\omega=2 \\pi f\\) with \\(f\\) being the specified frequency. GaussianSource The GaussianSource generates a pulsed electromagnetic source with a Gaussian temporal envelope modulating a carrier wave, designed for broadband frequency excitation while minimizing truncation effects through a shifted peak. $$ s(t)=\\exp \\left(-\\frac{\\left(t-t_0\\right)^2}{2 w^2}\\right) \\exp (-i \\omega t) $$ where \\(w\\) is the width parameter, \\(t_0=t_{\\text {start}}+c \\cdot w\\) with \\(c\\) being the cutoff (default 5.0) to shift the peak and avoid abrupt truncation at \\(t=t_{\\text {start}}\\) , and \\(\\omega=2 \\pi f\\) with \\(f\\) being the center frequency. ChirpedSource The ChirpedSource is a custom pulsed source featuring a Gaussian envelope with an added quadratic phase term to produce a linearly chirped frequency sweep, useful for applications requiring timevarying frequency content. $$ s(t)=\\exp \\left(i 2 \\pi f\\left(t-t_p\\right)\\right) \\exp \\left(-a\\left(t-t_p\\right)^2+i b\\left(t-t_p\\right)^2\\right) $$ where \\(f\\) is the base frequency, \\(t_p\\) is the peak time, \\(a\\) is the width parameter controlling the envelope decay, and \\(b\\) is the chirp rate introducing quadratic phase for frequency modulation. PulseSource When simulating an absorption spectrum, this source is required. The PulseSource creates a custom Gaussian-enveloped pulse with a sinusoidal carrier wave peaked at a specified time, suitable for simulating short electromagnetic bursts in time-domain simulations. $$ s(t)=\\exp \\left(i 2 \\pi f\\left(t-t_p\\right)\\right) \\exp \\left(-a\\left(t-t_p\\right)^2\\right) $$ where \\(f\\) is the carrier frequency, \\(t_p\\) is the peak time, and \\(a\\) is the width parameter determining the pulse duration. Other electric field shapes for quantum simulations can be supported using the other two shapes as templates, but additional options for the sources will need to be added to the input file parser in the input/params.py file under the getSource() method (found in the buildclassicalParams() method).","title":"sources.py"},{"location":"api-reference/#drivers","text":"","title":"drivers/"},{"location":"api-reference/#classicalpy","text":"Runs Meep simulation.","title":"classical.py"},{"location":"api-reference/#quantumpy","text":"Runs RT-TDDFT, supports multi-threading for transforms.","title":"quantum.py"},{"location":"api-reference/#plasmolpy","text":"Hybrid run.","title":"plasmol.py"},{"location":"api-reference/#utils","text":"utils.csv.initCSV(filename, comment) , updateCSV(...) . utils.plotting.show_eField_pField(eFieldFile, pFieldFile) . utils.fourier.transform(...) : Fourier transform and absorption spectrum. [TODO: Add full parameter lists, return types, or use Sphinx for auto-gen docs.]","title":"utils/"},{"location":"contributing/","text":"Contributing Guide Welcome contributors! Follow these steps to contribute. Development Setup Fork the repo. Install dev deps: pip install black pre-commit pytest . Run pre-commit install for hooks. Code Organization drivers/ : Simulation entry points (meep.py, etc.). quantum/ : Molecule, propagation, propagators/. meep/ : Simulation and sources. input/ : Parsing and params. utils/ : CSV, logging, plotting, etc. Use relative imports (e.g., from ..quantum import MOLECULE ). Adding Features Create branch: git checkout -b feature/new-prop . Write tests in tests/ . Update docs in docs/ . Submit PR with changelog entry. Coding Standards PEP 8 with Black formatter. Type hints and docstrings. Tests: pytest . [TODO: Add issue templates or specific guidelines.]","title":"Contributing"},{"location":"contributing/#contributing-guide","text":"Welcome contributors! Follow these steps to contribute.","title":"Contributing Guide"},{"location":"contributing/#development-setup","text":"Fork the repo. Install dev deps: pip install black pre-commit pytest . Run pre-commit install for hooks.","title":"Development Setup"},{"location":"contributing/#code-organization","text":"drivers/ : Simulation entry points (meep.py, etc.). quantum/ : Molecule, propagation, propagators/. meep/ : Simulation and sources. input/ : Parsing and params. utils/ : CSV, logging, plotting, etc. Use relative imports (e.g., from ..quantum import MOLECULE ).","title":"Code Organization"},{"location":"contributing/#adding-features","text":"Create branch: git checkout -b feature/new-prop . Write tests in tests/ . Update docs in docs/ . Submit PR with changelog entry.","title":"Adding Features"},{"location":"contributing/#coding-standards","text":"PEP 8 with Black formatter. Type hints and docstrings. Tests: pytest . [TODO: Add issue templates or specific guidelines.]","title":"Coding Standards"},{"location":"installation/","text":"Installation Guide PlasMol requires Python 3.8+ and several scientific libraries. Follow these steps to set up the environment. Prerequisites Python 3.8 or higher. Git (for cloning the repository). Optional: Conda or virtualenv for isolated environments. Step 1: Clone the Repository git clone https://github.com/yourusername/PlasMol.git # [TODO: Replace with actual repo URL] cd PlasMol Step 2: Create a Virtual Environment Using virtualenv: python -m venv env source env/bin/activate # On Windows: env\\Scripts\\activate Or with Conda: conda create -n plasmol python = 3 .12 conda activate plasmol Step 3: Install Dependencies PlasMol uses: - PySCF for quantum calculations. - Meep for electromagnetics. - NumPy, SciPy, Pandas, Matplotlib for data handling and plotting. Install via pip: pip install pyscf meep numpy scipy pandas matplotlib logging argparse # Optional for advanced features: torch (ML), biopython (if bio-related), etc. # [TODO: Add any other dependencies from your requirements.txt if available] Step 4: Install PlasMol as a Package (Optional) To make it importable system-wide: pip install -e . This assumes a setup.py or pyproject.toml in the root (e.g., for editable install). Step 5: Verify Installation Run a test: python -m src.main --help If you see the CLI help message, it's working. Common Issues Meep Installation : On some systems, Meep requires additional setup (e.g., conda install -c conda-forge meep for binaries). PySCF Errors : Ensure OpenBLAS or MKL is installed for performance. Import Errors : Run as a module ( python -m src.main ) from the project root to resolve relative imports. [TODO: Add platform-specific notes, e.g., for macOS/Linux/Windows.]","title":"Installation"},{"location":"installation/#installation-guide","text":"PlasMol requires Python 3.8+ and several scientific libraries. Follow these steps to set up the environment.","title":"Installation Guide"},{"location":"installation/#prerequisites","text":"Python 3.8 or higher. Git (for cloning the repository). Optional: Conda or virtualenv for isolated environments.","title":"Prerequisites"},{"location":"installation/#step-1-clone-the-repository","text":"git clone https://github.com/yourusername/PlasMol.git # [TODO: Replace with actual repo URL] cd PlasMol","title":"Step 1: Clone the Repository"},{"location":"installation/#step-2-create-a-virtual-environment","text":"Using virtualenv: python -m venv env source env/bin/activate # On Windows: env\\Scripts\\activate Or with Conda: conda create -n plasmol python = 3 .12 conda activate plasmol","title":"Step 2: Create a Virtual Environment"},{"location":"installation/#step-3-install-dependencies","text":"PlasMol uses: - PySCF for quantum calculations. - Meep for electromagnetics. - NumPy, SciPy, Pandas, Matplotlib for data handling and plotting. Install via pip: pip install pyscf meep numpy scipy pandas matplotlib logging argparse # Optional for advanced features: torch (ML), biopython (if bio-related), etc. # [TODO: Add any other dependencies from your requirements.txt if available]","title":"Step 3: Install Dependencies"},{"location":"installation/#step-4-install-plasmol-as-a-package-optional","text":"To make it importable system-wide: pip install -e . This assumes a setup.py or pyproject.toml in the root (e.g., for editable install).","title":"Step 4: Install PlasMol as a Package (Optional)"},{"location":"installation/#step-5-verify-installation","text":"Run a test: python -m src.main --help If you see the CLI help message, it's working.","title":"Step 5: Verify Installation"},{"location":"installation/#common-issues","text":"Meep Installation : On some systems, Meep requires additional setup (e.g., conda install -c conda-forge meep for binaries). PySCF Errors : Ensure OpenBLAS or MKL is installed for performance. Import Errors : Run as a module ( python -m src.main ) from the project root to resolve relative imports. [TODO: Add platform-specific notes, e.g., for macOS/Linux/Windows.]","title":"Common Issues"},{"location":"tutorials/","text":"Tutorials These tutorials demonstrate core workflows. Assume you've installed PlasMol. Tutorial 1: Simple Meep Simulation Create input.meep : ``` start meep simulation cellLength = 10 resolution = 20 pmlThickness = 1.0 end source sourceType = 'gaussian' frequency = 0.5 [etc.] end 2. Run: ```bash python -m src.main -f input.meep ``` 3. View outputs: Check eField.csv and GIF. Expected: Simulates Gaussian pulse propagation. ## Tutorial 2: RT-TDDFT Quantum Simulation 1. Create `input.quantum`: ``` start quantum rttddft basis = 'sto-3g' xc = 'lda' geometry H 0 0 0.0 0.0 O 1.0 0.0 0.0 end geometry end propagator = 'rk4' end source shape = 'pulse' wavelength_nm = 400 [etc.] end Run**: bash python -m src.main -f input.quantum -v Analyze: Use plotting.py to visualize fields; apply fourier.transform for spectrum. Expected: Propagates density matrix, outputs polarization and HOMO-LUMO jumps. Tutorial 3: Hybrid PlasMol Combine Meep and quantum inputs. Run similarly. [TODO: Add more detailed examples, code snippets, or Jupyter notebook links.]","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"These tutorials demonstrate core workflows. Assume you've installed PlasMol.","title":"Tutorials"},{"location":"tutorials/#tutorial-1-simple-meep-simulation","text":"Create input.meep : ``` start meep simulation cellLength = 10 resolution = 20 pmlThickness = 1.0 end source sourceType = 'gaussian' frequency = 0.5 [etc.] end 2. Run: ```bash python -m src.main -f input.meep ``` 3. View outputs: Check eField.csv and GIF. Expected: Simulates Gaussian pulse propagation. ## Tutorial 2: RT-TDDFT Quantum Simulation 1. Create `input.quantum`: ``` start quantum rttddft basis = 'sto-3g' xc = 'lda' geometry H 0 0 0.0 0.0 O 1.0 0.0 0.0 end geometry end propagator = 'rk4' end source shape = 'pulse' wavelength_nm = 400 [etc.] end Run**: bash python -m src.main -f input.quantum -v Analyze: Use plotting.py to visualize fields; apply fourier.transform for spectrum. Expected: Propagates density matrix, outputs polarization and HOMO-LUMO jumps.","title":"Tutorial 1: Simple Meep Simulation"},{"location":"tutorials/#tutorial-3-hybrid-plasmol","text":"Combine Meep and quantum inputs. Run similarly. [TODO: Add more detailed examples, code snippets, or Jupyter notebook links.]","title":"Tutorial 3: Hybrid PlasMol"},{"location":"usage/","text":"Usage Guide PlasMol is run via the command-line interface (CLI) from src/main.py . It supports three simulation types: Meep (electromagnetics), Quantum (RT-TDDFT), and PlasMol (hybrid). CLI Arguments python -m src.main -f <input_file> [ options ] - -f, --input <file> : Path to the input file (required). - -l, --log <file> : Log file name. - -v, --verbose : Increase verbosity (up to -vv for debug). - -r, --restart`: Restart simulation (deletes previous outputs). Input File Format Input files are divided into sections like start meep / end meep , start quantum / end quantum , and start settings / end settings . See examples in templates/ . Example snippet: start settings dt = 0.01 t_end = 100.0 eField_path = eField.csv end settings start meep [simulation parameters like cellLength, resolution] end meep start quantum [basis, xc, geometry, etc.] end quantum Running Simulations Pure Meep : python -m src.main -f templates/template-meep.in -v Outputs electric fields, HDF5 images, GIF (if enabled). Pure RT-TDDFT : python -m src.main -f templates/template-quantum.in -v polarization fields, spectra, checkpoints. Hybrid PlasMol : python -m src.main -f templates/template-plasmol.in -vv Combines both, with molecule-field interactions. Output Files CSV: eField.csv, pField.csv for fields. Plots: output.png (eV_spectrum.png for spectra). Checkpoint: .npz for resuming. GIF: Simulation visualizations if HDF5 enabled. Advanced Options Propagators: Set in quantum input (step, magnus2, rk4). Sources: Continuous, Gaussian, chirped, pulse in meep section. Restart: Use -r to clear old files and resume from checkpoint. [TODO: Add example input files or screenshots of output.]","title":"Usage"},{"location":"usage/#usage-guide","text":"PlasMol is run via the command-line interface (CLI) from src/main.py . It supports three simulation types: Meep (electromagnetics), Quantum (RT-TDDFT), and PlasMol (hybrid).","title":"Usage Guide"},{"location":"usage/#cli-arguments","text":"python -m src.main -f <input_file> [ options ] - -f, --input <file> : Path to the input file (required). - -l, --log <file> : Log file name. - -v, --verbose : Increase verbosity (up to -vv for debug). - -r, --restart`: Restart simulation (deletes previous outputs).","title":"CLI Arguments"},{"location":"usage/#input-file-format","text":"Input files are divided into sections like start meep / end meep , start quantum / end quantum , and start settings / end settings . See examples in templates/ . Example snippet: start settings dt = 0.01 t_end = 100.0 eField_path = eField.csv end settings start meep [simulation parameters like cellLength, resolution] end meep start quantum [basis, xc, geometry, etc.] end quantum","title":"Input File Format"},{"location":"usage/#running-simulations","text":"Pure Meep : python -m src.main -f templates/template-meep.in -v Outputs electric fields, HDF5 images, GIF (if enabled). Pure RT-TDDFT : python -m src.main -f templates/template-quantum.in -v polarization fields, spectra, checkpoints. Hybrid PlasMol : python -m src.main -f templates/template-plasmol.in -vv Combines both, with molecule-field interactions.","title":"Running Simulations"},{"location":"usage/#output-files","text":"CSV: eField.csv, pField.csv for fields. Plots: output.png (eV_spectrum.png for spectra). Checkpoint: .npz for resuming. GIF: Simulation visualizations if HDF5 enabled.","title":"Output Files"},{"location":"usage/#advanced-options","text":"Propagators: Set in quantum input (step, magnus2, rk4). Sources: Continuous, Gaussian, chirped, pulse in meep section. Restart: Use -r to clear old files and resume from checkpoint. [TODO: Add example input files or screenshots of output.]","title":"Advanced Options"}]}