{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PlasMol: Simulating Plasmon-Molecule Interactions PlasMol is an open-source tool for simulating plasmon-molecule interactions, combining classical Finite-Difference Time-Domain (FDTD) electromagnetics with quantum Real-Time Time-Dependent Density Functional Theory (RT-TDDFT). Built on Meep for FDTD and PySCF for quantum calculations, it enables studies of nanoparticle-molecule systems, such as plasmon-enhanced spectroscopy or SERS. Whether you're running isolated NP simulations, molecular RT-TDDFT, or full hybrid PlasMol runs, this package provides a flexible framework. For more details, see the About page . Key Features Simulation Modes : Classical FDTD: Simulate nanoparticles (e.g., gold/silver spheres) with custom sources. Quantum RT-TDDFT: Compute molecular responses like induced dipoles or absorption spectra. Full PlasMol: Couple FDTD and RT-TDDFT for plasmon-molecule dynamics. Customizable Sources : Continuous, Gaussian, chirped, or pulsed fields. Outputs : CSVs for fields/dipoles, HDF5 images/GIFs, absorption spectra, and checkpoints. Propagators : Step, RK4, or 2nd-order Magnus for RT-TDDFT. Extensible : Add custom tracking (e.g., SERS) via code injections\u2014see API Reference . Quick Start Installation PlasMol requires Python 3.8+ and dependencies like Meep and PySCF. For full steps, see the Installation Guide . git clone https://github.com/kombatEldridge/PlasMol.git cd PlasMol pip install -e . Basic Usage Run simulations via command line with an input file (e.g., from templates/ ): python src/main.py -f templates/template-plasmol.in -vv -l plasmol.log -r -f : Input file path. -vv : Debug logging. -l : Log file. -r : Restart (clears old outputs). For detailed instructions and examples, see Usage and Tutorials . Example: Full PlasMol Simulation Input snippet (from template-plasmol.in ): start general dt 0.1 t_end 4000 end general start quantum start rttddft start geometry O 0.0 0.0 - 0.13 H 1.49 0.0 1.03 H - 1.49 0.0 1.03 end geometry units bohr basis 6 - 31 g xc pbe0 propagator magnus2 end rttddft end quantum start classical start source sourceType continuous sourceCenter - 0.04 sourceSize 0 0.1 0.1 frequency 5 end source start simulation cellLength 0.1 pmlThickness 0.01 end simulation start object material Au radius 0.03 center 0 0 0 end object end classical Outputs include field CSVs and optional GIFs/spectra. Documentation Installation Guide : Step-by-step setup. Usage : Input file structure and parameters. Tutorials : Hands-on examples for classical, quantum, and full simulations. API Reference : Code details for customization. Contributing : How to add features or report issues. About : Project history, releases, and citations. Contributing Contributions are welcome! Whether fixing bugs, adding propagators/sources, or improving docs, check the Contributing Guide for details. Open an issue or PR on GitHub . We especially need help with test suites, new nanoparticle shapes, and SERS tracking. License GPL-3.0 License . Acknowledgments Built on Meep , PySCF , NumPy, and more. Contributors: Brinton Eldridge . Advisors: Dr. Daniel Nascimento, Dr. Yongmei Wang. Contact Email: bldrdge1@memphis.edu GitHub: kombatEldridge LinkedIn: Brinton Eldridge Star the repo if you find it useful! \u2b50","title":"Home"},{"location":"#plasmol-simulating-plasmon-molecule-interactions","text":"PlasMol is an open-source tool for simulating plasmon-molecule interactions, combining classical Finite-Difference Time-Domain (FDTD) electromagnetics with quantum Real-Time Time-Dependent Density Functional Theory (RT-TDDFT). Built on Meep for FDTD and PySCF for quantum calculations, it enables studies of nanoparticle-molecule systems, such as plasmon-enhanced spectroscopy or SERS. Whether you're running isolated NP simulations, molecular RT-TDDFT, or full hybrid PlasMol runs, this package provides a flexible framework. For more details, see the About page .","title":"PlasMol: Simulating Plasmon-Molecule Interactions"},{"location":"#key-features","text":"Simulation Modes : Classical FDTD: Simulate nanoparticles (e.g., gold/silver spheres) with custom sources. Quantum RT-TDDFT: Compute molecular responses like induced dipoles or absorption spectra. Full PlasMol: Couple FDTD and RT-TDDFT for plasmon-molecule dynamics. Customizable Sources : Continuous, Gaussian, chirped, or pulsed fields. Outputs : CSVs for fields/dipoles, HDF5 images/GIFs, absorption spectra, and checkpoints. Propagators : Step, RK4, or 2nd-order Magnus for RT-TDDFT. Extensible : Add custom tracking (e.g., SERS) via code injections\u2014see API Reference .","title":"Key Features"},{"location":"#quick-start","text":"","title":"Quick Start"},{"location":"#installation","text":"PlasMol requires Python 3.8+ and dependencies like Meep and PySCF. For full steps, see the Installation Guide . git clone https://github.com/kombatEldridge/PlasMol.git cd PlasMol pip install -e .","title":"Installation"},{"location":"#basic-usage","text":"Run simulations via command line with an input file (e.g., from templates/ ): python src/main.py -f templates/template-plasmol.in -vv -l plasmol.log -r -f : Input file path. -vv : Debug logging. -l : Log file. -r : Restart (clears old outputs). For detailed instructions and examples, see Usage and Tutorials .","title":"Basic Usage"},{"location":"#example-full-plasmol-simulation","text":"Input snippet (from template-plasmol.in ): start general dt 0.1 t_end 4000 end general start quantum start rttddft start geometry O 0.0 0.0 - 0.13 H 1.49 0.0 1.03 H - 1.49 0.0 1.03 end geometry units bohr basis 6 - 31 g xc pbe0 propagator magnus2 end rttddft end quantum start classical start source sourceType continuous sourceCenter - 0.04 sourceSize 0 0.1 0.1 frequency 5 end source start simulation cellLength 0.1 pmlThickness 0.01 end simulation start object material Au radius 0.03 center 0 0 0 end object end classical Outputs include field CSVs and optional GIFs/spectra.","title":"Example: Full PlasMol Simulation"},{"location":"#documentation","text":"Installation Guide : Step-by-step setup. Usage : Input file structure and parameters. Tutorials : Hands-on examples for classical, quantum, and full simulations. API Reference : Code details for customization. Contributing : How to add features or report issues. About : Project history, releases, and citations.","title":"Documentation"},{"location":"#contributing","text":"Contributions are welcome! Whether fixing bugs, adding propagators/sources, or improving docs, check the Contributing Guide for details. Open an issue or PR on GitHub . We especially need help with test suites, new nanoparticle shapes, and SERS tracking.","title":"Contributing"},{"location":"#license","text":"GPL-3.0 License .","title":"License"},{"location":"#acknowledgments","text":"Built on Meep , PySCF , NumPy, and more. Contributors: Brinton Eldridge . Advisors: Dr. Daniel Nascimento, Dr. Yongmei Wang.","title":"Acknowledgments"},{"location":"#contact","text":"Email: bldrdge1@memphis.edu GitHub: kombatEldridge LinkedIn: Brinton Eldridge Star the repo if you find it useful! \u2b50","title":"Contact"},{"location":"about/","text":"About PlasMol PlasMol is developed for simulating plasmon-molecule interactions, blending classical FDTD with quantum RT-TDDFT. Releases v1.0.0 : Initial release containing three main capabilities based on contents of the input file: Input contains Nanoparticle (NP) Only : The team behind Meep have built a fantastic codebase with powerful FDTD-based outcomes. When given only parameters surrounding the simulation of a NP, PlasMol acts as a wrapper to Meep, allowing for the simulation of one NP object at a time. As it is the basis of the FDTD implementation for PlasMol, we recommend users visit and use Meep directly, but this is an option in PlasMol for those who want to compare other PlasMol (NP + Molecule) results to an isolated NP simulation. By default, this option only produces real time images of the NP interacting with an electric field. By adding other input flags (described in the docs), PlasMol will track and produce a cross-section extinction spectrum of the NP. Commented sections in the codebase direct users to modify/add functions to track other desired outcomes. Input contains Molecule Only : For inputs with only molecule-based parameters, PlasMol will run a Real-Time Time Dependent Density Functional Theory (RT-TDDFT) simulation. Though more details can be found in the docs, briefly, without any NP present, PlasMol will track the electric field felt by the molecule and the induced dipole moment of the molecule. With some additional flags, PlasMol can produce an absorption spectrum of the molecule. Input contains NP and Molecule : This is the main purpose of PlasMol. A Meep simulation will begin with a molecule inside, whose initial electronic structure is built by PySCF. Every time step, the electric field at the molecule's position is measured and sent to the \"quantum\" portion of the code where the density matrix is propagated by the electric field. As an end result, the induced dipole moment of the molecule can be calculated. Finally, the induced dipole moment is fed back into the Meep simulation as the intensity of a point dipole at the position of the molecule. Call For Contributions (as of July 24th, 2025) This project has been a stepping stone for me in developing my expertise in modern quantum chemistry and computational methods. That being said, when I began work on PlasMol, I had loftier plans than just posting a minimal working version on GitHub, but plans and priorities change. As of the release of v1.0.0, work has paused on this project. For students in the same or adjacent fields, perhaps the PlasMol skeleton can inspire you to pick it up for your lab's specific desired outcomes. As is the nature of DFT work, one can track many things as a NP + Molecule simulation propagates by contracting the corresponding operator with the current density matrix. Empty commented sections are left in certain files to make adding custom functions easier. Particular work on monitoring SERS enhancements could put this code to great use, especially given that this was the original intention of the code. Citation There is no publication on this work presently. If I don't get around to getting a publication on this work before you want to use/modify it, please just drop a link in your work to the project's GitHub . License GPL-3.0 license Acknowledgments Libraries: Meep , PySCF , NumPy . Contributors: Brinton Eldridge . Advisors: Dr. Daniel Nascimento , Dr. Yongmei Wang . Contact Information Brinton Eldridge Email: bldrdge1@memphis.edu GitHub: https://github.com/kombatEldridge Organization: University of Memphis LinkedIn: https://www.linkedin.com/in/brinton-eldridge/","title":"About"},{"location":"about/#about-plasmol","text":"PlasMol is developed for simulating plasmon-molecule interactions, blending classical FDTD with quantum RT-TDDFT.","title":"About PlasMol"},{"location":"about/#releases","text":"v1.0.0 : Initial release containing three main capabilities based on contents of the input file: Input contains Nanoparticle (NP) Only : The team behind Meep have built a fantastic codebase with powerful FDTD-based outcomes. When given only parameters surrounding the simulation of a NP, PlasMol acts as a wrapper to Meep, allowing for the simulation of one NP object at a time. As it is the basis of the FDTD implementation for PlasMol, we recommend users visit and use Meep directly, but this is an option in PlasMol for those who want to compare other PlasMol (NP + Molecule) results to an isolated NP simulation. By default, this option only produces real time images of the NP interacting with an electric field. By adding other input flags (described in the docs), PlasMol will track and produce a cross-section extinction spectrum of the NP. Commented sections in the codebase direct users to modify/add functions to track other desired outcomes. Input contains Molecule Only : For inputs with only molecule-based parameters, PlasMol will run a Real-Time Time Dependent Density Functional Theory (RT-TDDFT) simulation. Though more details can be found in the docs, briefly, without any NP present, PlasMol will track the electric field felt by the molecule and the induced dipole moment of the molecule. With some additional flags, PlasMol can produce an absorption spectrum of the molecule. Input contains NP and Molecule : This is the main purpose of PlasMol. A Meep simulation will begin with a molecule inside, whose initial electronic structure is built by PySCF. Every time step, the electric field at the molecule's position is measured and sent to the \"quantum\" portion of the code where the density matrix is propagated by the electric field. As an end result, the induced dipole moment of the molecule can be calculated. Finally, the induced dipole moment is fed back into the Meep simulation as the intensity of a point dipole at the position of the molecule.","title":"Releases"},{"location":"about/#call-for-contributions","text":"(as of July 24th, 2025) This project has been a stepping stone for me in developing my expertise in modern quantum chemistry and computational methods. That being said, when I began work on PlasMol, I had loftier plans than just posting a minimal working version on GitHub, but plans and priorities change. As of the release of v1.0.0, work has paused on this project. For students in the same or adjacent fields, perhaps the PlasMol skeleton can inspire you to pick it up for your lab's specific desired outcomes. As is the nature of DFT work, one can track many things as a NP + Molecule simulation propagates by contracting the corresponding operator with the current density matrix. Empty commented sections are left in certain files to make adding custom functions easier. Particular work on monitoring SERS enhancements could put this code to great use, especially given that this was the original intention of the code.","title":"Call For Contributions"},{"location":"about/#citation","text":"There is no publication on this work presently. If I don't get around to getting a publication on this work before you want to use/modify it, please just drop a link in your work to the project's GitHub .","title":"Citation"},{"location":"about/#license","text":"GPL-3.0 license","title":"License"},{"location":"about/#acknowledgments","text":"Libraries: Meep , PySCF , NumPy . Contributors: Brinton Eldridge . Advisors: Dr. Daniel Nascimento , Dr. Yongmei Wang .","title":"Acknowledgments"},{"location":"about/#contact-information","text":"Brinton Eldridge Email: bldrdge1@memphis.edu GitHub: https://github.com/kombatEldridge Organization: University of Memphis LinkedIn: https://www.linkedin.com/in/brinton-eldridge/","title":"Contact Information"},{"location":"api-reference/","text":"API Reference This page documents key classes and methods, especially portions that can support custom injections for user's complete control over the simulation. If your changes to the code are a good fit for public use, feel free to read the contributing page. Directory Tree PlasMol | |_ docs | |_ *files for these docs* | |_ src | |_ __init__.py | |_ constants.py | |_ main.py | | | |_ classical | | |_ __init__.py | | |_ simulation.py | | |_ sources.py | | | |_ drivers | | |_ __init__.py | | |_ classical.py | | |_ plasmol.py | | |_ quantum.py | | | |_ input | | |_ __init__.py | | |_ cli.py | | |_ params.py | | |_ parser.py | | | |_ quantum | | |_ __init__.py | | |_ chkfile.py | | |_ electric_field.py | | |_ molecule.py | | |_ propagation.py | | |_ propagators | | |_ __init__.py | | |_ magnus2.py | | |_ rk4.py | | |_ step.py | | | |_ utils | | |_ __init__.py | | |_ csv.py | | |_ fourier.py | | |_ gif.py | | |_ logging.py | | |_ plotting.py | |_ templates |_ *files for Tutorial section* classical/ This directory contains all files necessary to simulate a nanoparticle in PlasMol. Included in it is the main file that runs both the classical and full PlasMol simulations ( simulation.py ) as well as the file used to build the electric fields in the simulations from input parameters ( sources.py ). simulation.py Runs Meep and full PlasMol simulation, handles sources, PML, symmetries. For those who want to add tracking to certain parameters, a commented section can be found in the run() method and right above it. An example code block is added (but commented out) to the run() method to graph the 3D model of the NP. sources.py Currently supports ContinuousSource The ContinuousSource provides a continuous-wave electromagnetic source with constant frequency and amplitude that activates abruptly at the start time and persists until the optional end time. $$ s(t)=\\theta\\left(t-t_{\\text {start}}\\right) \\exp (-i \\omega t) $$ where \\(\\theta\\) is the Heaviside step function, \\(t_{\\text {start}}\\) is the start time (default 0), and \\(\\omega=2 \\pi f\\) with \\(f\\) being the specified frequency. GaussianSource The GaussianSource generates a pulsed electromagnetic source with a Gaussian temporal envelope modulating a carrier wave, designed for broadband frequency excitation while minimizing truncation effects through a shifted peak. $$ s(t)=\\exp \\left(-\\frac{\\left(t-t_0\\right)^2}{2 w^2}\\right) \\exp (-i \\omega t) $$ where \\(w\\) is the width parameter, \\(t_0=t_{\\text {start}}+c \\cdot w\\) with \\(c\\) being the cutoff (default 5.0) to shift the peak and avoid abrupt truncation at \\(t=t_{\\text {start}}\\) , and \\(\\omega=2 \\pi f\\) with \\(f\\) being the center frequency. ChirpedSource The ChirpedSource is a custom pulsed source featuring a Gaussian envelope with an added quadratic phase term to produce a linearly chirped frequency sweep, useful for applications requiring time varying frequency content. $$ s(t)=\\exp \\left(i 2 \\pi f\\left(t-t_p\\right)\\right) \\exp \\left(-a\\left(t-t_p\\right)^2+i b\\left(t-t_p\\right)^2\\right) $$ where \\(f\\) is the base frequency, \\(t_p\\) is the peak time, \\(a\\) is the width parameter controlling the envelope decay, and \\(b\\) is the chirp rate introducing quadratic phase for frequency modulation. PulseSource When simulating an absorption spectrum, this source is required. The PulseSource creates a custom Gaussian-enveloped pulse with a sinusoidal carrier wave peaked at a specified time, suitable for simulating short electromagnetic bursts in time-domain simulations. $$ s(t)=\\exp \\left(i 2 \\pi f\\left(t-t_p\\right)\\right) \\exp \\left(-a\\left(t-t_p\\right)^2\\right) $$ where \\(f\\) is the carrier frequency, \\(t_p\\) is the peak time, and \\(a\\) is the width parameter determining the pulse duration. Other electric field shapes for the classical and full PlasMol simulations can be supported using these four as templates, but additional options for the sources will need to be added to the input file parser in the input/params.py file under the getSource() method (found in the buildclassicalParams() method). drivers/ For each type of simulation running, a surface-level file determines what steps to take to achieve the desired results. The reasoning for each type of simulation can be found on the Usage page. classical.py Is chosen to run a MEEP simulation when only classical parameters are specified in the input file. A classical run has the capability to construct and run a MEEP simulation, as well as produce 2D cross-sections of the simulation at the center of the NP if the hdf5 block is added to the input file. As previous discussed, other methods can be injected in the classical/simulation.py file to track other properties (like the commented out getElectricField() method which can track the electric field intensity at any pre-determined, hard-coded point). quantum.py Is chosen to run an RT-TDDFT simulation when only quantum parameters are specified in the input file. A quantum run by default will perform a single RT-TDDFT simulation given a molecule and an incident electric field. However, if transform is specified in the rttddft block of the input file, the simulation should be given an ultrafast pulse to perform a real time absorption spectrum calculation with three multithreaded simulations, one for each directional Gaussian pulse, and then a Fourier transform is performed to give the absorption spectrum (see Tutorial #3 ). plasmol.py Is chosen to run a full PlasMol simulation when both classical and quantum parameters are specified in the input file. This is the main purpose of PlasMol. A Meep simulation will begin with a molecule inside, whose initial electronic structure is built by PySCF. Every time step, the electric field at the molecule's position is measured and sent to the \"quantum\" portion of the code where the density matrix is propagated by the electric field. As an end result, the induced dipole moment of the molecule can be calculated. Finally, the induced dipole moment is fed back into the Meep simulation as the intensity of a point dipole at the position of the molecule. input/ Users should mainly interact with PlasMol through command line, calling upon the main.py script. To feed parameters into the simulation, users only have a few command line options (controlled by cli.py ) and one input file (initially parsed by parser.py and then fit for the PlasMol codebase using params.py ). cli.py Enumerates command line flags to be included when running PlasMol. Command line options include --input (or -f for file): Path to the PlasMol input file. --log (or -l ): Path to the log file. If not specified, log prints to terminal and is not saved. --verbose (or -v and -vv ): Specifies verbosity levels. Not specified: logs only logger.warning calls. -v : logs up to logger.info calls. -vv : logs up to logger.debug calls. --restart (or -r ): Tries to remove the following files from current working directory in case they are leftover from previous runs. Actual file names for these can be specified in the input file. eField_path pField_path chkfile path pField_Transform_path eField_vs_pField_path eV_spectrum_path parser.py Reads input file to determine what type of simulation is needed (classical, quantum, PlasMol). If needed, users should add new input line support to this file, as well as params.py . params.py After being told what type of simulation to run, this file prepares the PARAMS class which holds all necessary parameters for the simulations. If needed, users should add new input line support to this file, as well as parser.py . quantum/ This directory contains all files necessary to simulate a molecule in PlasMol. Included in it is the file to build the molecule ( molecule.py ), the file to build the electric field for just a quantum simulation ( electric_field.py ), the file to continually update the checkpoint files if called for ( chkfile.py ), and the files for propagating the density matrix of the molecule ( propagation.py and propagators/* ). molecule.py Initializes molecule with PySCF, handles SCF, Fock matrix, dipole calculations. Additional methods can be injected at the bottom of this class to track other quantum properties. For example, we track the induced dipole using the calculate_mu() method and then inject the call to this method in the propagation.py file. electric_field.py Builds electric fields (pulse or kick shapes) for the molecule to feel only when a quantum simulation is chosen. If classical or full PlasMol simulation is running, the electric field is generated inside the Meep simulation (using classical/sources.py ). Other electric field shapes for quantum simulations can be added to the build_field() method using the other two shapes as templates. propagation.py Is called every time step, either by the quantum simulation in drivers/quantum.py or during the classical or full PlasMol simulations in classical/simulation.py inside callQuantum() . Additional methods can be injected into molecule.py to track other quantum properties and called at the bottom of this file. chkfile.py Save a checkpoint file containing the current state of the simulation, as specified by the chkfile frequency in the input file. Always saves the timestamp \\(t\\) , ground state density matrix \\(\\mathbf{D}_{\\text{AO}}(0)\\) , and the coefficient matrix at the timestamp \\(\\mathbf{C}(t)\\) . Additionally, it will save the orthogonalized coefficient matrix at the previous timestamp \\(\\mathbf{C}_{\\text{ortho}}(t-\\Delta t)\\) for the Magnus step propagator. the orthogonalized Fock matrix at the previous half timestamp \\(\\mathbf{F}_{\\text{ortho}}(t-\\frac{1}{2}\\Delta t)\\) for the 2nd order Magnus propagator. If a new propagator is added, any necessary quantities will need to be added to this file. quantum/propagators/ To complete the main loop of RT-TDDFT, the density matrix (here propagated using the coefficient matrix) should be propagated under some incident field. PlasMol has three propagators available. The Magnus step method ( step.py ) and the Runge-Kutta 4 ( rk4.py ) methods both do a fairly poor job at propagating at small time steps, but are given here as a comparative tool to the superior 2nd order Magnus (with a Predictor-Corrector loop) method ( Magnus2.py ). Though the 2nd order Magnus method is the field's standard, shorter and lower resolution simulations can be run for debugging using the former two methods. step.py Propagates molecular orbitals using the Magnus step method. This method is also known as the modified midpoint unitary transformation (MMUT) scheme from https://doi.org/10.1039/B415849K \\[ \\begin{gathered} \\mathbf{F}_{\\text {orth }}=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}, \\vec{\\mathbf{E}}\\right)\\\\ \\mathbf{U} =\\exp \\left(-2 i \\Delta t \\cdot \\mathbf{F}_{\\text {orth}} (t)\\right)\\\\ \\mathbf{C}_{\\text{ortho}} \\left(t + \\Delta t\\right)= \\mathbf{U} \\mathbf{C}_{\\text{ortho}} \\left(t - \\Delta t\\right) \\end{gathered} \\] rk4.py Propagates molecular orbitals using the Runge-Kutta 4 method. \\[ \\begin{gathered} \\mathbf{F}_{\\text {orth }}=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}, \\vec{\\mathbf{E}}\\right)\\\\ k _1=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth }} \\\\ \\mathbf{C}_{\\text {orth, } 1}= \\mathbf{C}_{\\text {orth }}+\\frac{1}{2} k _1 \\\\ k _2=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 1} \\\\ \\mathbf{C}_{\\text {orth, } 2}= \\mathbf{C}_{\\text {orth }}+\\frac{1}{2} k _2 \\\\ k _3=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 2} \\\\ \\mathbf{C}_{\\text {orth, } 3}= \\mathbf{C}_{\\text {orth }}+ k _3 \\\\ k _4=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 3} \\\\ \\mathbf{C}_{\\text {orth }}(t+\\Delta t)= \\mathbf{C}_{\\text {orth }}+\\frac{ k _1}{6}+\\frac{ k _2}{3}+\\frac{ k _3}{3}+\\frac{ k _4}{6} \\end{gathered} \\] magnus2.py Propagates molecular orbitals using the second order Magnus method with a predictor-corrector algorithm included. This method is described in many RT-TDDFT papers, but I found the derivation from https://doi.org/10.1021/ct501078d to be very understandable. \\[ \\mathbf{F}_{\\text{orth }}^{(0)}(t+\\Delta t / 2)=2 \\mathbf{F}_{\\text{orth }}(t)- \\mathbf{F}_{\\text{orth }}(t-\\Delta t / 2) \\] Then, for iterations \\(k=0,1,2, \\ldots\\) until convergence or maximum iterations exceeded: \\[ \\begin{gathered} \\mathbf{U}^{(k)}=\\exp \\left(-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }}^{(k)}(t+\\Delta t / 2)\\right) \\\\ \\mathbf{C}_{\\text {orth }}^{(k+1)}(t+\\Delta t)= \\mathbf{U}^{(k)} \\mathbf{C}_{\\text {orth }}(t) \\\\ \\mathbf{C}^{(k+1)}(t+\\Delta t)=\\text {molecule.rotate_coeff_away_from_orth}\\left( \\mathbf{C}_{\\text {orth }}^{(k+1)}(t+\\Delta t)\\right) \\\\ \\mathbf{D}_{\\text {AO }}^{(k+1)}(t+\\Delta t)=\\text {molecule.make_rdm1}\\left( \\mathbf{C}^{(k+1)}(t+\\Delta t), \\text { occ }\\right) \\\\ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t)=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}^{(k+1)}(t+\\Delta t), \\vec{\\mathbf{E}}\\right) \\end{gathered} \\] Update the midpoint guess for the next iteration: \\[ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t / 2)=\\frac{1}{2}\\left( \\mathbf{F}_{\\text {orth }}(t)+ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t)\\right) \\] Convergence is checked starting from the second iteration ( \\(k \\geq 1\\) ) as: \\[ \\left\\| \\mathbf{C}^{(k+1)}(t+\\Delta t)- \\mathbf{C}^{(k)}(t+\\Delta t)\\right\\|<\\epsilon \\] where \\(\\epsilon=\\) params.pc_convergence . Upon convergence, assign the final values to the molecule object: \\[ \\begin{gathered} \\mathbf{C}(t+\\Delta t)= \\mathbf{C}^{(\\text {final})}(t+\\Delta t), \\quad \\mathbf{D} _{\\text{AO}}(t+\\Delta t)= \\mathbf{D} _{\\text{AO}}^{(\\text {final})}(t+\\Delta t) \\\\ \\mathbf{F}_{\\text {orth }}(t+\\Delta t)= \\mathbf{F}_{\\text {orth }}^{(\\text {final})}(t+\\Delta t), \\quad \\mathbf{F}_{\\text {orth }}(t+\\Delta t / 2)= \\mathbf{F}_{\\text {orth }}^{(\\text {final})}(t+\\Delta t / 2) \\end{gathered} \\] The updated \\(\\mathbf{F}_{\\text{orth }}(t+\\Delta t / 2)\\) is stored for extrapolation in the next time step. utils/ This directory stores files that add utilities to the PlasMol codebase, but are too large or cumbersome to be placed inside other files. Such files include the handler for reading and writing to csv files ( csv.py ), the handler for creating a gif from the generated hdf5 files ( gif.py ), the handler for logging ( logging.py ), the handler for plotting data found in csv files ( plotting.py ), and the methods for Fourier transforming the data for the absorption spectra ( fourier.py ).","title":"API Reference"},{"location":"api-reference/#api-reference","text":"This page documents key classes and methods, especially portions that can support custom injections for user's complete control over the simulation. If your changes to the code are a good fit for public use, feel free to read the contributing page.","title":"API Reference"},{"location":"api-reference/#directory-tree","text":"PlasMol | |_ docs | |_ *files for these docs* | |_ src | |_ __init__.py | |_ constants.py | |_ main.py | | | |_ classical | | |_ __init__.py | | |_ simulation.py | | |_ sources.py | | | |_ drivers | | |_ __init__.py | | |_ classical.py | | |_ plasmol.py | | |_ quantum.py | | | |_ input | | |_ __init__.py | | |_ cli.py | | |_ params.py | | |_ parser.py | | | |_ quantum | | |_ __init__.py | | |_ chkfile.py | | |_ electric_field.py | | |_ molecule.py | | |_ propagation.py | | |_ propagators | | |_ __init__.py | | |_ magnus2.py | | |_ rk4.py | | |_ step.py | | | |_ utils | | |_ __init__.py | | |_ csv.py | | |_ fourier.py | | |_ gif.py | | |_ logging.py | | |_ plotting.py | |_ templates |_ *files for Tutorial section*","title":"Directory Tree"},{"location":"api-reference/#classical","text":"This directory contains all files necessary to simulate a nanoparticle in PlasMol. Included in it is the main file that runs both the classical and full PlasMol simulations ( simulation.py ) as well as the file used to build the electric fields in the simulations from input parameters ( sources.py ).","title":"classical/"},{"location":"api-reference/#simulationpy","text":"Runs Meep and full PlasMol simulation, handles sources, PML, symmetries. For those who want to add tracking to certain parameters, a commented section can be found in the run() method and right above it. An example code block is added (but commented out) to the run() method to graph the 3D model of the NP.","title":"simulation.py"},{"location":"api-reference/#sourcespy","text":"Currently supports ContinuousSource The ContinuousSource provides a continuous-wave electromagnetic source with constant frequency and amplitude that activates abruptly at the start time and persists until the optional end time. $$ s(t)=\\theta\\left(t-t_{\\text {start}}\\right) \\exp (-i \\omega t) $$ where \\(\\theta\\) is the Heaviside step function, \\(t_{\\text {start}}\\) is the start time (default 0), and \\(\\omega=2 \\pi f\\) with \\(f\\) being the specified frequency. GaussianSource The GaussianSource generates a pulsed electromagnetic source with a Gaussian temporal envelope modulating a carrier wave, designed for broadband frequency excitation while minimizing truncation effects through a shifted peak. $$ s(t)=\\exp \\left(-\\frac{\\left(t-t_0\\right)^2}{2 w^2}\\right) \\exp (-i \\omega t) $$ where \\(w\\) is the width parameter, \\(t_0=t_{\\text {start}}+c \\cdot w\\) with \\(c\\) being the cutoff (default 5.0) to shift the peak and avoid abrupt truncation at \\(t=t_{\\text {start}}\\) , and \\(\\omega=2 \\pi f\\) with \\(f\\) being the center frequency. ChirpedSource The ChirpedSource is a custom pulsed source featuring a Gaussian envelope with an added quadratic phase term to produce a linearly chirped frequency sweep, useful for applications requiring time varying frequency content. $$ s(t)=\\exp \\left(i 2 \\pi f\\left(t-t_p\\right)\\right) \\exp \\left(-a\\left(t-t_p\\right)^2+i b\\left(t-t_p\\right)^2\\right) $$ where \\(f\\) is the base frequency, \\(t_p\\) is the peak time, \\(a\\) is the width parameter controlling the envelope decay, and \\(b\\) is the chirp rate introducing quadratic phase for frequency modulation. PulseSource When simulating an absorption spectrum, this source is required. The PulseSource creates a custom Gaussian-enveloped pulse with a sinusoidal carrier wave peaked at a specified time, suitable for simulating short electromagnetic bursts in time-domain simulations. $$ s(t)=\\exp \\left(i 2 \\pi f\\left(t-t_p\\right)\\right) \\exp \\left(-a\\left(t-t_p\\right)^2\\right) $$ where \\(f\\) is the carrier frequency, \\(t_p\\) is the peak time, and \\(a\\) is the width parameter determining the pulse duration. Other electric field shapes for the classical and full PlasMol simulations can be supported using these four as templates, but additional options for the sources will need to be added to the input file parser in the input/params.py file under the getSource() method (found in the buildclassicalParams() method).","title":"sources.py"},{"location":"api-reference/#drivers","text":"For each type of simulation running, a surface-level file determines what steps to take to achieve the desired results. The reasoning for each type of simulation can be found on the Usage page.","title":"drivers/"},{"location":"api-reference/#classicalpy","text":"Is chosen to run a MEEP simulation when only classical parameters are specified in the input file. A classical run has the capability to construct and run a MEEP simulation, as well as produce 2D cross-sections of the simulation at the center of the NP if the hdf5 block is added to the input file. As previous discussed, other methods can be injected in the classical/simulation.py file to track other properties (like the commented out getElectricField() method which can track the electric field intensity at any pre-determined, hard-coded point).","title":"classical.py"},{"location":"api-reference/#quantumpy","text":"Is chosen to run an RT-TDDFT simulation when only quantum parameters are specified in the input file. A quantum run by default will perform a single RT-TDDFT simulation given a molecule and an incident electric field. However, if transform is specified in the rttddft block of the input file, the simulation should be given an ultrafast pulse to perform a real time absorption spectrum calculation with three multithreaded simulations, one for each directional Gaussian pulse, and then a Fourier transform is performed to give the absorption spectrum (see Tutorial #3 ).","title":"quantum.py"},{"location":"api-reference/#plasmolpy","text":"Is chosen to run a full PlasMol simulation when both classical and quantum parameters are specified in the input file. This is the main purpose of PlasMol. A Meep simulation will begin with a molecule inside, whose initial electronic structure is built by PySCF. Every time step, the electric field at the molecule's position is measured and sent to the \"quantum\" portion of the code where the density matrix is propagated by the electric field. As an end result, the induced dipole moment of the molecule can be calculated. Finally, the induced dipole moment is fed back into the Meep simulation as the intensity of a point dipole at the position of the molecule.","title":"plasmol.py"},{"location":"api-reference/#input","text":"Users should mainly interact with PlasMol through command line, calling upon the main.py script. To feed parameters into the simulation, users only have a few command line options (controlled by cli.py ) and one input file (initially parsed by parser.py and then fit for the PlasMol codebase using params.py ).","title":"input/"},{"location":"api-reference/#clipy","text":"Enumerates command line flags to be included when running PlasMol. Command line options include --input (or -f for file): Path to the PlasMol input file. --log (or -l ): Path to the log file. If not specified, log prints to terminal and is not saved. --verbose (or -v and -vv ): Specifies verbosity levels. Not specified: logs only logger.warning calls. -v : logs up to logger.info calls. -vv : logs up to logger.debug calls. --restart (or -r ): Tries to remove the following files from current working directory in case they are leftover from previous runs. Actual file names for these can be specified in the input file. eField_path pField_path chkfile path pField_Transform_path eField_vs_pField_path eV_spectrum_path","title":"cli.py"},{"location":"api-reference/#parserpy","text":"Reads input file to determine what type of simulation is needed (classical, quantum, PlasMol). If needed, users should add new input line support to this file, as well as params.py .","title":"parser.py"},{"location":"api-reference/#paramspy","text":"After being told what type of simulation to run, this file prepares the PARAMS class which holds all necessary parameters for the simulations. If needed, users should add new input line support to this file, as well as parser.py .","title":"params.py"},{"location":"api-reference/#quantum","text":"This directory contains all files necessary to simulate a molecule in PlasMol. Included in it is the file to build the molecule ( molecule.py ), the file to build the electric field for just a quantum simulation ( electric_field.py ), the file to continually update the checkpoint files if called for ( chkfile.py ), and the files for propagating the density matrix of the molecule ( propagation.py and propagators/* ).","title":"quantum/"},{"location":"api-reference/#moleculepy","text":"Initializes molecule with PySCF, handles SCF, Fock matrix, dipole calculations. Additional methods can be injected at the bottom of this class to track other quantum properties. For example, we track the induced dipole using the calculate_mu() method and then inject the call to this method in the propagation.py file.","title":"molecule.py"},{"location":"api-reference/#electric_fieldpy","text":"Builds electric fields (pulse or kick shapes) for the molecule to feel only when a quantum simulation is chosen. If classical or full PlasMol simulation is running, the electric field is generated inside the Meep simulation (using classical/sources.py ). Other electric field shapes for quantum simulations can be added to the build_field() method using the other two shapes as templates.","title":"electric_field.py"},{"location":"api-reference/#propagationpy","text":"Is called every time step, either by the quantum simulation in drivers/quantum.py or during the classical or full PlasMol simulations in classical/simulation.py inside callQuantum() . Additional methods can be injected into molecule.py to track other quantum properties and called at the bottom of this file.","title":"propagation.py"},{"location":"api-reference/#chkfilepy","text":"Save a checkpoint file containing the current state of the simulation, as specified by the chkfile frequency in the input file. Always saves the timestamp \\(t\\) , ground state density matrix \\(\\mathbf{D}_{\\text{AO}}(0)\\) , and the coefficient matrix at the timestamp \\(\\mathbf{C}(t)\\) . Additionally, it will save the orthogonalized coefficient matrix at the previous timestamp \\(\\mathbf{C}_{\\text{ortho}}(t-\\Delta t)\\) for the Magnus step propagator. the orthogonalized Fock matrix at the previous half timestamp \\(\\mathbf{F}_{\\text{ortho}}(t-\\frac{1}{2}\\Delta t)\\) for the 2nd order Magnus propagator. If a new propagator is added, any necessary quantities will need to be added to this file.","title":"chkfile.py"},{"location":"api-reference/#quantumpropagators","text":"To complete the main loop of RT-TDDFT, the density matrix (here propagated using the coefficient matrix) should be propagated under some incident field. PlasMol has three propagators available. The Magnus step method ( step.py ) and the Runge-Kutta 4 ( rk4.py ) methods both do a fairly poor job at propagating at small time steps, but are given here as a comparative tool to the superior 2nd order Magnus (with a Predictor-Corrector loop) method ( Magnus2.py ). Though the 2nd order Magnus method is the field's standard, shorter and lower resolution simulations can be run for debugging using the former two methods.","title":"quantum/propagators/"},{"location":"api-reference/#steppy","text":"Propagates molecular orbitals using the Magnus step method. This method is also known as the modified midpoint unitary transformation (MMUT) scheme from https://doi.org/10.1039/B415849K \\[ \\begin{gathered} \\mathbf{F}_{\\text {orth }}=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}, \\vec{\\mathbf{E}}\\right)\\\\ \\mathbf{U} =\\exp \\left(-2 i \\Delta t \\cdot \\mathbf{F}_{\\text {orth}} (t)\\right)\\\\ \\mathbf{C}_{\\text{ortho}} \\left(t + \\Delta t\\right)= \\mathbf{U} \\mathbf{C}_{\\text{ortho}} \\left(t - \\Delta t\\right) \\end{gathered} \\]","title":"step.py"},{"location":"api-reference/#rk4py","text":"Propagates molecular orbitals using the Runge-Kutta 4 method. \\[ \\begin{gathered} \\mathbf{F}_{\\text {orth }}=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}, \\vec{\\mathbf{E}}\\right)\\\\ k _1=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth }} \\\\ \\mathbf{C}_{\\text {orth, } 1}= \\mathbf{C}_{\\text {orth }}+\\frac{1}{2} k _1 \\\\ k _2=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 1} \\\\ \\mathbf{C}_{\\text {orth, } 2}= \\mathbf{C}_{\\text {orth }}+\\frac{1}{2} k _2 \\\\ k _3=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 2} \\\\ \\mathbf{C}_{\\text {orth, } 3}= \\mathbf{C}_{\\text {orth }}+ k _3 \\\\ k _4=-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }} \\mathbf{C}_{\\text {orth, } 3} \\\\ \\mathbf{C}_{\\text {orth }}(t+\\Delta t)= \\mathbf{C}_{\\text {orth }}+\\frac{ k _1}{6}+\\frac{ k _2}{3}+\\frac{ k _3}{3}+\\frac{ k _4}{6} \\end{gathered} \\]","title":"rk4.py"},{"location":"api-reference/#magnus2py","text":"Propagates molecular orbitals using the second order Magnus method with a predictor-corrector algorithm included. This method is described in many RT-TDDFT papers, but I found the derivation from https://doi.org/10.1021/ct501078d to be very understandable. \\[ \\mathbf{F}_{\\text{orth }}^{(0)}(t+\\Delta t / 2)=2 \\mathbf{F}_{\\text{orth }}(t)- \\mathbf{F}_{\\text{orth }}(t-\\Delta t / 2) \\] Then, for iterations \\(k=0,1,2, \\ldots\\) until convergence or maximum iterations exceeded: \\[ \\begin{gathered} \\mathbf{U}^{(k)}=\\exp \\left(-i \\Delta t \\cdot \\mathbf{F}_{\\text {orth }}^{(k)}(t+\\Delta t / 2)\\right) \\\\ \\mathbf{C}_{\\text {orth }}^{(k+1)}(t+\\Delta t)= \\mathbf{U}^{(k)} \\mathbf{C}_{\\text {orth }}(t) \\\\ \\mathbf{C}^{(k+1)}(t+\\Delta t)=\\text {molecule.rotate_coeff_away_from_orth}\\left( \\mathbf{C}_{\\text {orth }}^{(k+1)}(t+\\Delta t)\\right) \\\\ \\mathbf{D}_{\\text {AO }}^{(k+1)}(t+\\Delta t)=\\text {molecule.make_rdm1}\\left( \\mathbf{C}^{(k+1)}(t+\\Delta t), \\text { occ }\\right) \\\\ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t)=\\text {molecule.get_F_orth}\\left( \\mathbf{D}_{\\text {AO }}^{(k+1)}(t+\\Delta t), \\vec{\\mathbf{E}}\\right) \\end{gathered} \\] Update the midpoint guess for the next iteration: \\[ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t / 2)=\\frac{1}{2}\\left( \\mathbf{F}_{\\text {orth }}(t)+ \\mathbf{F}_{\\text {orth }}^{(k+1)}(t+\\Delta t)\\right) \\] Convergence is checked starting from the second iteration ( \\(k \\geq 1\\) ) as: \\[ \\left\\| \\mathbf{C}^{(k+1)}(t+\\Delta t)- \\mathbf{C}^{(k)}(t+\\Delta t)\\right\\|<\\epsilon \\] where \\(\\epsilon=\\) params.pc_convergence . Upon convergence, assign the final values to the molecule object: \\[ \\begin{gathered} \\mathbf{C}(t+\\Delta t)= \\mathbf{C}^{(\\text {final})}(t+\\Delta t), \\quad \\mathbf{D} _{\\text{AO}}(t+\\Delta t)= \\mathbf{D} _{\\text{AO}}^{(\\text {final})}(t+\\Delta t) \\\\ \\mathbf{F}_{\\text {orth }}(t+\\Delta t)= \\mathbf{F}_{\\text {orth }}^{(\\text {final})}(t+\\Delta t), \\quad \\mathbf{F}_{\\text {orth }}(t+\\Delta t / 2)= \\mathbf{F}_{\\text {orth }}^{(\\text {final})}(t+\\Delta t / 2) \\end{gathered} \\] The updated \\(\\mathbf{F}_{\\text{orth }}(t+\\Delta t / 2)\\) is stored for extrapolation in the next time step.","title":"magnus2.py"},{"location":"api-reference/#utils","text":"This directory stores files that add utilities to the PlasMol codebase, but are too large or cumbersome to be placed inside other files. Such files include the handler for reading and writing to csv files ( csv.py ), the handler for creating a gif from the generated hdf5 files ( gif.py ), the handler for logging ( logging.py ), the handler for plotting data found in csv files ( plotting.py ), and the methods for Fourier transforming the data for the absorption spectra ( fourier.py ).","title":"utils/"},{"location":"contributing/","text":"Contributing Guide As of the release of v1.0.0, work has paused on this project. For students in the same or adjacent fields, perhaps the PlasMol skeleton can inspire you to pick it up for your lab's specific desired outcomes. As is the nature of DFT work, one can track many things as a NP + Molecule simulation propagates by contracting the corresponding operator with the current density matrix. Empty commented sections are left in certain files to make adding custom functions easier. Particular work on monitoring SERS enhancements could put this code to great use, especially given that this was the original intention of the code. Adding Features For contributors who want their code added to the main branch, submitting a PR would be good. General guidelines for doing so can be found on GitHub's docs . Most needed contributions Of course, bolstering the list of supported nanoparticle shapes or the supported electric field shapes (for the classical side and quantum side) would be nice, but the main concern is a test suite right now for those contributions to be helpful.","title":"Contributing"},{"location":"contributing/#contributing-guide","text":"As of the release of v1.0.0, work has paused on this project. For students in the same or adjacent fields, perhaps the PlasMol skeleton can inspire you to pick it up for your lab's specific desired outcomes. As is the nature of DFT work, one can track many things as a NP + Molecule simulation propagates by contracting the corresponding operator with the current density matrix. Empty commented sections are left in certain files to make adding custom functions easier. Particular work on monitoring SERS enhancements could put this code to great use, especially given that this was the original intention of the code.","title":"Contributing Guide"},{"location":"contributing/#adding-features","text":"For contributors who want their code added to the main branch, submitting a PR would be good. General guidelines for doing so can be found on GitHub's docs .","title":"Adding Features"},{"location":"contributing/#most-needed-contributions","text":"Of course, bolstering the list of supported nanoparticle shapes or the supported electric field shapes (for the classical side and quantum side) would be nice, but the main concern is a test suite right now for those contributions to be helpful.","title":"Most needed contributions"},{"location":"installation/","text":"Installation Guide PlasMol requires Python 3.8+ and several scientific libraries. Follow these steps to set up the environment. Prerequisites Python 3.8 or higher. Git (for cloning the repository). Optional: Conda or virtualenv for isolated environments. Step 0: Install MEEP Please visit the installation page for MEEP to install it for use in PlasMol. Step 1: Clone the Repository git clone https://github.com/kombatEldridge/PlasMol.git # [TODO: Replace with actual repo URL] cd PlasMol Step 2: Create a Virtual Environment If a virtual/conda environment for MEEP was not used for install, you can set up one here. Using virtualenv: python -m venv plasmol source plasmol/bin/activate # On Windows: env\\Scripts\\activate Or with Conda: conda create -n plasmol python = 3 .12 conda activate plasmol Step 3: Install Dependencies PlasMol uses: Meep for electromagnetics (should already be installed). PySCF for quantum calculations. NumPy, SciPy, Pandas, Matplotlib for data handling and plotting. Install via pip: pip install pyscf numpy scipy pandas matplotlib logging argparse Step 4: Install PlasMol as a Package (Optional) To make it importable system-wide: pip install -e . This assumes a setup.py or pyproject.toml in the root (e.g., for editable install). Step 5: Verify Installation Run a test: python -m src.main --help If you see the CLI help message, it's working.","title":"Installation"},{"location":"installation/#installation-guide","text":"PlasMol requires Python 3.8+ and several scientific libraries. Follow these steps to set up the environment.","title":"Installation Guide"},{"location":"installation/#prerequisites","text":"Python 3.8 or higher. Git (for cloning the repository). Optional: Conda or virtualenv for isolated environments.","title":"Prerequisites"},{"location":"installation/#step-0-install-meep","text":"Please visit the installation page for MEEP to install it for use in PlasMol.","title":"Step 0: Install MEEP"},{"location":"installation/#step-1-clone-the-repository","text":"git clone https://github.com/kombatEldridge/PlasMol.git # [TODO: Replace with actual repo URL] cd PlasMol","title":"Step 1: Clone the Repository"},{"location":"installation/#step-2-create-a-virtual-environment","text":"If a virtual/conda environment for MEEP was not used for install, you can set up one here. Using virtualenv: python -m venv plasmol source plasmol/bin/activate # On Windows: env\\Scripts\\activate Or with Conda: conda create -n plasmol python = 3 .12 conda activate plasmol","title":"Step 2: Create a Virtual Environment"},{"location":"installation/#step-3-install-dependencies","text":"PlasMol uses: Meep for electromagnetics (should already be installed). PySCF for quantum calculations. NumPy, SciPy, Pandas, Matplotlib for data handling and plotting. Install via pip: pip install pyscf numpy scipy pandas matplotlib logging argparse","title":"Step 3: Install Dependencies"},{"location":"installation/#step-4-install-plasmol-as-a-package-optional","text":"To make it importable system-wide: pip install -e . This assumes a setup.py or pyproject.toml in the root (e.g., for editable install).","title":"Step 4: Install PlasMol as a Package (Optional)"},{"location":"installation/#step-5-verify-installation","text":"Run a test: python -m src.main --help If you see the CLI help message, it's working.","title":"Step 5: Verify Installation"},{"location":"methodology/","text":"Theory and Methodology of PlasMol PlasMol is a hybrid simulation tool designed to model plasmon-molecule interactions by coupling classical Finite-Difference Time-Domain (FDTD) electromagnetics with quantum Real-Time Time-Dependent Density Functional Theory (RT-TDDFT). This document outlines the theoretical foundations and methodological workflow of PlasMol, drawing from its codebase and the provided schematic. The schematic illustrates the integration between quantum mechanical (QM) software, a handler for coupling, and classical FDTD (e.g., MEEP for electromagnetic propagation). Introduction PlasMol enables three simulation modes: Classical Only : FDTD simulation of nanoparticles (NPs) using MEEP. Quantum Only : RT-TDDFT simulation of molecules. Full PlasMol : Coupled FDTD-RT-TDDFT for NP-molecule systems. The core innovation lies in the bidirectional coupling: the electric field from the classical simulation drives quantum propagation, while the induced molecular dipole feeds back into the classical field as a point source. This allows modeling phenomena like plasmon-enhanced spectroscopy or Surface-Enhanced Raman Scattering (SERS). The schematic highlights: QM side: Time-dependent Fock matrix and integrals. Handler: Density matrix propagation and dipole calculation. MEEP side: Maxwell's equations with polarization source. Classical Component: FDTD with MEEP The classical part simulates electromagnetic fields around NPs using MEEP's FDTD solver. Key equations from the schematic (right side) describe field propagation: \\[ \\nabla \\times \\tilde{\\mathbf{E}}(t) = -\\mu \\frac{\\partial \\tilde{\\mathbf{H}}(t)}{\\partial t} \\] \\[ \\nabla \\times \\tilde{\\mathbf{H}}(t) = \\epsilon \\frac{\\partial \\tilde{\\mathbf{E}}(t)}{\\partial t} + \\frac{\\partial \\tilde{\\mathbf{P}}(t)}{\\partial t} \\] Here, \\(\\tilde{\\mathbf{E}}\\) and \\(\\tilde{\\mathbf{H}}\\) are the electric and magnetic fields, \\(\\epsilon\\) and \\(\\mu\\) are permittivity and permeability, and \\(\\tilde{\\mathbf{P}}(t)\\) is the polarization (from quantum feedback in the full PlasMol mode). Supported Features Sources : Continuous, Gaussian, chirped, or pulsed waves (see src/classical/sources.py ). Geometry : Spheres (Au/Ag materials); extensible to other shapes. Boundaries : Perfectly Matched Layers (PML). Outputs : HDF5 images, GIFs, field CSVs; custom tracking (e.g., extinction spectra) via injections in src/classical/simulation.py . In the full PlasMol mode, the induced dipole \\(\\tilde{\\mathbf{P}}(t)\\) is injected as a custom source at the molecule's position. Quantum Component: RT-TDDFT with PySCF The quantum part computes molecular responses using RT-TDDFT in PySCF. The time-dependent Fock matrix (from the schematic, left side) is: \\[ F_{\\mu\\nu}(t) = T_{\\mu\\nu} + V_{\\mu\\nu} + J_{\\mu\\nu}(t) - K_{\\mu\\nu}(t) - \\sum_{a \\in x,y,z} \\mu_a \\tilde{E}_a(t) \\] Where: \\(T_{\\mu\\nu}\\) : Kinetic energy integral: \\[ T_{\\mu\\nu} = \\int \\phi_\\mu(\\mathbf{r}) \\left( -\\frac{1}{2} \\nabla^2 \\right) \\phi_\\nu(\\mathbf{r}) \\, d\\mathbf{r} \\] \\(V_{\\mu\\nu}\\) : Nuclear attraction integral: \\[ V_{\\mu\\nu} = \\int \\phi_\\mu(\\mathbf{r}) \\left( -\\sum_A \\frac{Z_A}{|\\mathbf{R}_A - \\mathbf{r}|} \\right) \\phi_\\nu(\\mathbf{r}) \\, d\\mathbf{r} \\] \\(J_{\\mu\\nu}(t)\\) : Coulomb integral (time-dependent via density): \\[ J_{\\mu\\nu} = \\sum_{\\lambda\\sigma} D_{\\lambda\\sigma} \\iint \\phi^*_\\mu(\\mathbf{r}_1) \\phi_\\nu(\\mathbf{r}_1) \\left( \\frac{1}{r_{12}} \\right) \\phi^*_\\sigma(\\mathbf{r}_2) \\phi_\\sigma(\\mathbf{r}_2) \\, d\\mathbf{r}_1 d\\mathbf{r}_2 \\] \\(K_{\\mu\\nu}(t)\\) : Exchange integral (similarly time-dependent): \\[ K_{\\mu\\nu} = \\frac{1}{2} \\sum_{\\lambda\\sigma} D_{\\lambda\\sigma} \\iint \\phi^*_\\mu(\\mathbf{r}_1) \\phi_\\lambda(\\mathbf{r}_1) \\left( \\frac{1}{r_{12}} \\right) \\phi^*_\\sigma(\\mathbf{r}_2) \\phi_\\nu(\\mathbf{r}_2) \\, d\\mathbf{r}_1 d\\mathbf{r}_2 \\] The external field term \\(-\\sum \\mu_a \\tilde{E}_a(t)\\) couples to the classical field. Density Matrix Evolution The density matrix \\(\\mathbf{D}(t)\\) evolves under the Liouville-von Neumann equation (schematic, handler): \\[ \\frac{\\partial \\mathbf{D}(t)}{\\partial t} = [ \\mathbf{F}(t), \\mathbf{D}(t) ] \\] In practice, PlasMol propagates molecular orbitals \\(\\mathbf{C}(t)\\) in an orthogonal basis and reconstructs \\(\\mathbf{D}(t)\\) . Supported Propagators PlasMol offers three methods (see Propagators for more details): Step (Modified Midpoint Unitary Transformation - MMUT) : \\[ \\mathbf{C}_{\\text{ortho}}(t + \\Delta t) = \\exp(-i \\cdot 2\\Delta t \\cdot \\mathbf{F}_{\\text{ortho}}(t)) \\cdot \\mathbf{C}_{\\text{ortho}}(t - \\Delta t) \\] Runge-Kutta 4 (RK4) : \\[ \\mathbf{C}_{\\text{ortho}}(t + \\Delta t) = \\mathbf{C}_{\\text{ortho}}(t) + \\frac{k_1 + 2k_2 + 2k_3 + k_4}{6} \\] With intermediate \\(k_i\\) terms computed via Fock matrix multiplications. 2nd-Order Magnus with Predictor-Corrector (Recommended): Initial extrapolation: \\[ \\mathbf{F}_{\\text{ortho}}^{(0)}(t + \\Delta t / 2) = 2 \\mathbf{F}_{\\text{ortho}}(t) - \\mathbf{F}_{\\text{ortho}}(t - \\Delta t / 2) \\] Iterative update until convergence: \\[ \\mathbf{C}_{\\text{ortho}}^{(k+1)}(t + \\Delta t) = \\exp(-i \\Delta t \\cdot \\mathbf{F}_{\\text{ortho}}^{(k)}(t + \\Delta t / 2)) \\cdot \\mathbf{C}_{\\text{ortho}}(t) \\] From the schematic (handler, propagation method): \\[ \\tilde{\\mathbf{P}}(t + dt) = \\frac{3}{4 \\tau a^3} \\operatorname{Tr}[\\mathbf{D}(t + dt) \\cdot \\mu] - \\operatorname{Tr}[\\mathbf{D}_0 \\cdot \\mu] \\] This induced polarization \\(\\tilde{\\mathbf{P}}(t)\\) is fed back to MEEP. Absorption Spectra With the transform flag, PlasMol runs three directional simulations and applies a Fourier transform (see src/utils/fourier.py ). Coupling Mechanism: Handler The \"Handler\" bridges QM and classical parts (schematic, center): QM to Classical : Induced dipole from RT-TDDFT is injected as a point source in MEEP. Classical to QM : Electric field at the molecule's position drives Fock matrix updates. Workflow (per time step in src/classical/simulation.py and src/quantum/propagation.py ): (Before simulation starts to loop) Generate ground state matrices using PySCF. Extract \\(\\tilde{\\mathbf{E}}(t)\\) from MEEP at molecule position. Propagate \\(\\mathbf{D}(t)\\) using chosen method. Compute \\(\\tilde{\\mathbf{P}}(t)\\) via dipole contraction. Update MEEP source with \\(\\partial \\tilde{\\mathbf{P}} / \\partial t\\) . This loop enables self-consistent hybrid dynamics. Methodology Workflow Input Parsing : src/input/ processes blocks for classical/quantum parameters. Initialization : Classical: Build MEEP simulation ( src/classical/simulation.py ). Quantum: Build molecule and initial state ( src/quantum/molecule.py ). Simulation Loop : Advance FDTD step in MEEP. If molecule present and field exceeds cutoff: Call RT-TDDFT propagation. Inject dipole back as source. Outputs : CSVs, plots, checkpoints via src/utils/ . Extensions : Custom injections for tracking (e.g., SERS) in commented sections. For code details, see API Reference .","title":"Methodology"},{"location":"methodology/#theory-and-methodology-of-plasmol","text":"PlasMol is a hybrid simulation tool designed to model plasmon-molecule interactions by coupling classical Finite-Difference Time-Domain (FDTD) electromagnetics with quantum Real-Time Time-Dependent Density Functional Theory (RT-TDDFT). This document outlines the theoretical foundations and methodological workflow of PlasMol, drawing from its codebase and the provided schematic. The schematic illustrates the integration between quantum mechanical (QM) software, a handler for coupling, and classical FDTD (e.g., MEEP for electromagnetic propagation).","title":"Theory and Methodology of PlasMol"},{"location":"methodology/#introduction","text":"PlasMol enables three simulation modes: Classical Only : FDTD simulation of nanoparticles (NPs) using MEEP. Quantum Only : RT-TDDFT simulation of molecules. Full PlasMol : Coupled FDTD-RT-TDDFT for NP-molecule systems. The core innovation lies in the bidirectional coupling: the electric field from the classical simulation drives quantum propagation, while the induced molecular dipole feeds back into the classical field as a point source. This allows modeling phenomena like plasmon-enhanced spectroscopy or Surface-Enhanced Raman Scattering (SERS). The schematic highlights: QM side: Time-dependent Fock matrix and integrals. Handler: Density matrix propagation and dipole calculation. MEEP side: Maxwell's equations with polarization source.","title":"Introduction"},{"location":"methodology/#classical-component-fdtd-with-meep","text":"The classical part simulates electromagnetic fields around NPs using MEEP's FDTD solver. Key equations from the schematic (right side) describe field propagation: \\[ \\nabla \\times \\tilde{\\mathbf{E}}(t) = -\\mu \\frac{\\partial \\tilde{\\mathbf{H}}(t)}{\\partial t} \\] \\[ \\nabla \\times \\tilde{\\mathbf{H}}(t) = \\epsilon \\frac{\\partial \\tilde{\\mathbf{E}}(t)}{\\partial t} + \\frac{\\partial \\tilde{\\mathbf{P}}(t)}{\\partial t} \\] Here, \\(\\tilde{\\mathbf{E}}\\) and \\(\\tilde{\\mathbf{H}}\\) are the electric and magnetic fields, \\(\\epsilon\\) and \\(\\mu\\) are permittivity and permeability, and \\(\\tilde{\\mathbf{P}}(t)\\) is the polarization (from quantum feedback in the full PlasMol mode).","title":"Classical Component: FDTD with MEEP"},{"location":"methodology/#supported-features","text":"Sources : Continuous, Gaussian, chirped, or pulsed waves (see src/classical/sources.py ). Geometry : Spheres (Au/Ag materials); extensible to other shapes. Boundaries : Perfectly Matched Layers (PML). Outputs : HDF5 images, GIFs, field CSVs; custom tracking (e.g., extinction spectra) via injections in src/classical/simulation.py . In the full PlasMol mode, the induced dipole \\(\\tilde{\\mathbf{P}}(t)\\) is injected as a custom source at the molecule's position.","title":"Supported Features"},{"location":"methodology/#quantum-component-rt-tddft-with-pyscf","text":"The quantum part computes molecular responses using RT-TDDFT in PySCF. The time-dependent Fock matrix (from the schematic, left side) is: \\[ F_{\\mu\\nu}(t) = T_{\\mu\\nu} + V_{\\mu\\nu} + J_{\\mu\\nu}(t) - K_{\\mu\\nu}(t) - \\sum_{a \\in x,y,z} \\mu_a \\tilde{E}_a(t) \\] Where: \\(T_{\\mu\\nu}\\) : Kinetic energy integral: \\[ T_{\\mu\\nu} = \\int \\phi_\\mu(\\mathbf{r}) \\left( -\\frac{1}{2} \\nabla^2 \\right) \\phi_\\nu(\\mathbf{r}) \\, d\\mathbf{r} \\] \\(V_{\\mu\\nu}\\) : Nuclear attraction integral: \\[ V_{\\mu\\nu} = \\int \\phi_\\mu(\\mathbf{r}) \\left( -\\sum_A \\frac{Z_A}{|\\mathbf{R}_A - \\mathbf{r}|} \\right) \\phi_\\nu(\\mathbf{r}) \\, d\\mathbf{r} \\] \\(J_{\\mu\\nu}(t)\\) : Coulomb integral (time-dependent via density): \\[ J_{\\mu\\nu} = \\sum_{\\lambda\\sigma} D_{\\lambda\\sigma} \\iint \\phi^*_\\mu(\\mathbf{r}_1) \\phi_\\nu(\\mathbf{r}_1) \\left( \\frac{1}{r_{12}} \\right) \\phi^*_\\sigma(\\mathbf{r}_2) \\phi_\\sigma(\\mathbf{r}_2) \\, d\\mathbf{r}_1 d\\mathbf{r}_2 \\] \\(K_{\\mu\\nu}(t)\\) : Exchange integral (similarly time-dependent): \\[ K_{\\mu\\nu} = \\frac{1}{2} \\sum_{\\lambda\\sigma} D_{\\lambda\\sigma} \\iint \\phi^*_\\mu(\\mathbf{r}_1) \\phi_\\lambda(\\mathbf{r}_1) \\left( \\frac{1}{r_{12}} \\right) \\phi^*_\\sigma(\\mathbf{r}_2) \\phi_\\nu(\\mathbf{r}_2) \\, d\\mathbf{r}_1 d\\mathbf{r}_2 \\] The external field term \\(-\\sum \\mu_a \\tilde{E}_a(t)\\) couples to the classical field.","title":"Quantum Component: RT-TDDFT with PySCF"},{"location":"methodology/#density-matrix-evolution","text":"The density matrix \\(\\mathbf{D}(t)\\) evolves under the Liouville-von Neumann equation (schematic, handler): \\[ \\frac{\\partial \\mathbf{D}(t)}{\\partial t} = [ \\mathbf{F}(t), \\mathbf{D}(t) ] \\] In practice, PlasMol propagates molecular orbitals \\(\\mathbf{C}(t)\\) in an orthogonal basis and reconstructs \\(\\mathbf{D}(t)\\) .","title":"Density Matrix Evolution"},{"location":"methodology/#supported-propagators","text":"PlasMol offers three methods (see Propagators for more details): Step (Modified Midpoint Unitary Transformation - MMUT) : \\[ \\mathbf{C}_{\\text{ortho}}(t + \\Delta t) = \\exp(-i \\cdot 2\\Delta t \\cdot \\mathbf{F}_{\\text{ortho}}(t)) \\cdot \\mathbf{C}_{\\text{ortho}}(t - \\Delta t) \\] Runge-Kutta 4 (RK4) : \\[ \\mathbf{C}_{\\text{ortho}}(t + \\Delta t) = \\mathbf{C}_{\\text{ortho}}(t) + \\frac{k_1 + 2k_2 + 2k_3 + k_4}{6} \\] With intermediate \\(k_i\\) terms computed via Fock matrix multiplications. 2nd-Order Magnus with Predictor-Corrector (Recommended): Initial extrapolation: \\[ \\mathbf{F}_{\\text{ortho}}^{(0)}(t + \\Delta t / 2) = 2 \\mathbf{F}_{\\text{ortho}}(t) - \\mathbf{F}_{\\text{ortho}}(t - \\Delta t / 2) \\] Iterative update until convergence: \\[ \\mathbf{C}_{\\text{ortho}}^{(k+1)}(t + \\Delta t) = \\exp(-i \\Delta t \\cdot \\mathbf{F}_{\\text{ortho}}^{(k)}(t + \\Delta t / 2)) \\cdot \\mathbf{C}_{\\text{ortho}}(t) \\] From the schematic (handler, propagation method): \\[ \\tilde{\\mathbf{P}}(t + dt) = \\frac{3}{4 \\tau a^3} \\operatorname{Tr}[\\mathbf{D}(t + dt) \\cdot \\mu] - \\operatorname{Tr}[\\mathbf{D}_0 \\cdot \\mu] \\] This induced polarization \\(\\tilde{\\mathbf{P}}(t)\\) is fed back to MEEP.","title":"Supported Propagators"},{"location":"methodology/#absorption-spectra","text":"With the transform flag, PlasMol runs three directional simulations and applies a Fourier transform (see src/utils/fourier.py ).","title":"Absorption Spectra"},{"location":"methodology/#coupling-mechanism-handler","text":"The \"Handler\" bridges QM and classical parts (schematic, center): QM to Classical : Induced dipole from RT-TDDFT is injected as a point source in MEEP. Classical to QM : Electric field at the molecule's position drives Fock matrix updates. Workflow (per time step in src/classical/simulation.py and src/quantum/propagation.py ): (Before simulation starts to loop) Generate ground state matrices using PySCF. Extract \\(\\tilde{\\mathbf{E}}(t)\\) from MEEP at molecule position. Propagate \\(\\mathbf{D}(t)\\) using chosen method. Compute \\(\\tilde{\\mathbf{P}}(t)\\) via dipole contraction. Update MEEP source with \\(\\partial \\tilde{\\mathbf{P}} / \\partial t\\) . This loop enables self-consistent hybrid dynamics.","title":"Coupling Mechanism: Handler"},{"location":"methodology/#methodology-workflow","text":"Input Parsing : src/input/ processes blocks for classical/quantum parameters. Initialization : Classical: Build MEEP simulation ( src/classical/simulation.py ). Quantum: Build molecule and initial state ( src/quantum/molecule.py ). Simulation Loop : Advance FDTD step in MEEP. If molecule present and field exceeds cutoff: Call RT-TDDFT propagation. Inject dipole back as source. Outputs : CSVs, plots, checkpoints via src/utils/ . Extensions : Custom injections for tracking (e.g., SERS) in commented sections. For code details, see API Reference .","title":"Methodology Workflow"},{"location":"tutorials/","text":"Tutorials This section provides hands-on tutorials for using PlasMol. Each tutorial uses a template input file from the templates/ directory. Run commands from your project root, e.g.: python src/main.p -f templates/template-classical.in -vv -l plasmol.log Outputs will appear in your working directory (e.g., CSVs, images). Tutorial 1: Classical NP Simulation (FDTD Only) Simulate a gold nanoparticle interacting with a continuous electric field. This demonstrates basic FDTD output, including the optional cross-section images. Prepare Input : Copy template-classical.in and adjust parameters (e.g., increase t_end for longer simulation). Example snippet: start general -- 'general' block wrappers are not necessary dt 0.1 -- au t_end 50 -- au eField_path eField . csv end general -- classical portion start classical start source sourceType continuous sourceCenter - 0.04 sourceSize 0 0.1 0.1 frequency 5 end source start simulation cellLength 0.1 pmlThickness 0.01 -- spherical objects with an incident electric field propagating in the -- +y direction with a z electric component will have the following symmetry symmetries Y 1 Z - 1 surroundingMaterialIndex 1.33 -- surrounds NP in water end simulation start object material Au radius 0.03 center 0 0 0 end object start hdf5 timestepsBetween 1 -- saves a picture every timestep intensityMin 3 intensityMax 10 imageDirName hello -- saves images to path hello/. end hdf5 end classical Run Simulation : python src/main.py -f /path/to/classical.in -vv -l plasmol.log or python -m src.main -f /path/to/classical.in -vv -l plasmol.log View Outputs : eField.csv : Electric field data. Path defined in input file. hello/ : PNG cross-sections (if HDF5 enabled); a GIF is auto-generated. Cross-section of a spherical nanoparticle in the xy-plane receiving incident light, whose electric component is measured in the z-direction. Dashed outline added for clarity. For extinction spectra, add custom tracking in src/classical/simulation.py (see API Reference ). Using instructions from MEEP's documentation and code examples , one can compare the Qext spectrum between the FDTD and DDA methods, implemented using MEEP and DDSCAT respectively. Tutorial 2: Quantum Molecule Simulation (RT-TDDFT Only) Compute the induced dipole of a water molecule using a pulsed field. This uses only RT-TDDFT. Prepare Input : Copy template-quantum.in . Unless you want an absorption spectrum (see Tutorial 3 ), do not add transform to rttddft block. Example snippet: start general -- 'general' block wrappers are not necessary dt 0.05 -- au t_end 1000 -- au eField_path eField . csv end general -- rt-tddft portion start quantum start rttddft start geometry O 0.0000000000 0.0000000000 - 0.1302052882 H 1.4891244004 0.0000000000 1.0332262019 H - 1.4891244004 0.0000000000 1.0332262019 end geometry units bohr check_tolerance 1e-12 charge 0 spin 0 basis 6 - 31 g xc pbe0 resplimit 1e-20 propagator magnus2 pc_convergence 1e-12 maxiter 200 transform -- important to include this flag for abs spectrum simulation end rttddft start files start chkfile -- in case simulation crashes frequency 100 path chkfile . npz end chkfile pField_path pField . csv pField_Transform_path pField - transformed . npz eField_vs_pField_path output . png eV_spectrum_path spectrum . png -- this image will display the absorption spectrum end files start source shape pulse peak_time_au 200 width_steps 1000 wavelength_nm 400 -- nm intensity_au 5e-5 dir z end source end quantum Run Simulation : python src/main.py -f /path/to/quantum.in -vv -l plasmol.log -r or python -m src.main -f /path/to/quantum.in -vv -l plasmol.log -r View Outputs : eField.csv : Incident field; plots using src/utils/plotting.py for visualization. pField.csv : Induced dipole (polarization) data. Example spectra comparing a pulse felt by the molecule (left) with the molecule's induced dipole (right). Inset highlights molecules small oscillations due to excitement. Tutorial 3: Molecular Absorption Spectrum (RT-TDDFT with transform flag) Compute the absorption spectrum of a water molecule using three Dirac delta kicks. This uses multithreaded RT-TDDFT and Fourier transform. Prepare Input : Copy template-quantum.in . Enable transform for spectrum calculation. Example snippet: start general -- 'general' block wrappers are not necessary dt 0.1 -- au t_end 4000 -- au eField_path eField . csv end general -- rt-tddft portion start quantum start rttddft start geometry O 0.0000000000 0.0000000000 - 0.1302052882 H 1.4891244004 0.0000000000 1.0332262019 H - 1.4891244004 0.0000000000 1.0332262019 end geometry units bohr check_tolerance 1e-12 charge 0 spin 0 basis 6 - 31 g xc pbe0 resplimit 1e-20 propagator magnus2 pc_convergence 1e-12 maxiter 200 transform -- important to include this flag for abs spectrum simulation end rttddft start files start chkfile -- in case simulation crashes frequency 100 path chkfile . npz end chkfile pField_path pField . csv pField_Transform_path pField - transformed . npz eField_vs_pField_path output . png eV_spectrum_path spectrum . png -- this image will display the absorption spectrum end files start source shape kick -- needs to be a delta 'kick', not 'pulse' peak_time_au 0.1 width_steps 5 intensity_au 5e-5 -- dir z -- do not need to specify direction when transform flag used end source end quantum Run Simulation : python src/main.py -f /path/to/abs_spectrum.in -vv -l plasmol.log -r or python -m src.main -f /path/to/abs_spectrum.in -vv -l plasmol.log -r View Outputs : pField.csv : Induced dipole (polarization) data. spectrum.png : Absorption spectrum plot. Absorption spectrum run as compared to an LR-TDDFT standard from nwchem. Tutorial 4: Full PlasMol Simulation (NP + Molecule) Simulate a gold NP with a water molecule inside, tracking plasmon-molecule interactions. Prepare Input : Copy template-plasmol.in . Combine classical NP with quantum molecule. Example snippet: ```lua start general -- 'general' block wrappers are not necessary dt 0.1 -- au t_end 4000 -- au eField_path eField.csv end general -- rt-tddft portion start quantum start rttddft start geometry O 0.0000000000 0.0000000000 -0.1302052882 H 1.4891244004 0.0000000000 1.0332262019 H -1.4891244004 0.0000000000 1.0332262019 end geometry units bohr check_tolerance 1e-12 charge 0 spin 0 basis 6-31g xc pbe0 resplimit 1e-20 propagator magnus2 pc_convergence 1e-12 maxiter 200 transform -- important to include this flag for abs spectrum simulation end rttddft start files start chkfile -- in case simulation crashes frequency 100 path chkfile.npz end chkfile pField_path pField.csv pField_Transform_path pField-transformed.npz eField_vs_pField_path output.png eV_spectrum_path spectrum.png -- this image will display the absorption spectrum end files -- if source is given in quantum block but a classical block is found, -- this source will be ignored. -- start source -- shape kick -- peak_time_au 0.1 -- width_steps 5 -- intensity_au 5e-5 -- end source end quantum -- classical portion start classical start source sourceType continuous sourceCenter -0.04 sourceSize 0 0.1 0.1 frequency 5 end source start simulation cellLength 0.1 pmlThickness 0.01 -- spherical objects with an incident electric field propagating in the -- +y direction with a z electric component will have the following symmetry symmetries Y 1 Z -1 surroundingMaterialIndex 1.33 -- surrounds NP in water end simulation start object material Au radius 0.03 center 0 0 0 end object start hdf5 timestepsBetween 1 -- saves a picture every timestep intensityMin 3 intensityMax 10 imageDirName hello -- saves images to path hello/. end hdf5 end classical ``` Run Simulation : python src/main.py -f /path/to/plasmol.in -vv -l plasmol.log -r or python -m src.main -f /path/to/plasmol.in -vv -l plasmol.log -r View Outputs : Similar images, gifs, and spectra to the tutorials above can be found in this instance too. For SERS or other metrics, inject custom functions (see API Reference ). These tutorials cover basics\u2014experiment with parameters and check logs for issues. For advanced topics, see API Reference .","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"This section provides hands-on tutorials for using PlasMol. Each tutorial uses a template input file from the templates/ directory. Run commands from your project root, e.g.: python src/main.p -f templates/template-classical.in -vv -l plasmol.log Outputs will appear in your working directory (e.g., CSVs, images).","title":"Tutorials"},{"location":"tutorials/#tutorial-1-classical-np-simulation-fdtd-only","text":"Simulate a gold nanoparticle interacting with a continuous electric field. This demonstrates basic FDTD output, including the optional cross-section images. Prepare Input : Copy template-classical.in and adjust parameters (e.g., increase t_end for longer simulation). Example snippet: start general -- 'general' block wrappers are not necessary dt 0.1 -- au t_end 50 -- au eField_path eField . csv end general -- classical portion start classical start source sourceType continuous sourceCenter - 0.04 sourceSize 0 0.1 0.1 frequency 5 end source start simulation cellLength 0.1 pmlThickness 0.01 -- spherical objects with an incident electric field propagating in the -- +y direction with a z electric component will have the following symmetry symmetries Y 1 Z - 1 surroundingMaterialIndex 1.33 -- surrounds NP in water end simulation start object material Au radius 0.03 center 0 0 0 end object start hdf5 timestepsBetween 1 -- saves a picture every timestep intensityMin 3 intensityMax 10 imageDirName hello -- saves images to path hello/. end hdf5 end classical Run Simulation : python src/main.py -f /path/to/classical.in -vv -l plasmol.log or python -m src.main -f /path/to/classical.in -vv -l plasmol.log View Outputs : eField.csv : Electric field data. Path defined in input file. hello/ : PNG cross-sections (if HDF5 enabled); a GIF is auto-generated. Cross-section of a spherical nanoparticle in the xy-plane receiving incident light, whose electric component is measured in the z-direction. Dashed outline added for clarity. For extinction spectra, add custom tracking in src/classical/simulation.py (see API Reference ). Using instructions from MEEP's documentation and code examples , one can compare the Qext spectrum between the FDTD and DDA methods, implemented using MEEP and DDSCAT respectively.","title":"Tutorial 1: Classical NP Simulation (FDTD Only)"},{"location":"tutorials/#tutorial-2-quantum-molecule-simulation-rt-tddft-only","text":"Compute the induced dipole of a water molecule using a pulsed field. This uses only RT-TDDFT. Prepare Input : Copy template-quantum.in . Unless you want an absorption spectrum (see Tutorial 3 ), do not add transform to rttddft block. Example snippet: start general -- 'general' block wrappers are not necessary dt 0.05 -- au t_end 1000 -- au eField_path eField . csv end general -- rt-tddft portion start quantum start rttddft start geometry O 0.0000000000 0.0000000000 - 0.1302052882 H 1.4891244004 0.0000000000 1.0332262019 H - 1.4891244004 0.0000000000 1.0332262019 end geometry units bohr check_tolerance 1e-12 charge 0 spin 0 basis 6 - 31 g xc pbe0 resplimit 1e-20 propagator magnus2 pc_convergence 1e-12 maxiter 200 transform -- important to include this flag for abs spectrum simulation end rttddft start files start chkfile -- in case simulation crashes frequency 100 path chkfile . npz end chkfile pField_path pField . csv pField_Transform_path pField - transformed . npz eField_vs_pField_path output . png eV_spectrum_path spectrum . png -- this image will display the absorption spectrum end files start source shape pulse peak_time_au 200 width_steps 1000 wavelength_nm 400 -- nm intensity_au 5e-5 dir z end source end quantum Run Simulation : python src/main.py -f /path/to/quantum.in -vv -l plasmol.log -r or python -m src.main -f /path/to/quantum.in -vv -l plasmol.log -r View Outputs : eField.csv : Incident field; plots using src/utils/plotting.py for visualization. pField.csv : Induced dipole (polarization) data. Example spectra comparing a pulse felt by the molecule (left) with the molecule's induced dipole (right). Inset highlights molecules small oscillations due to excitement.","title":"Tutorial 2: Quantum Molecule Simulation (RT-TDDFT Only)"},{"location":"tutorials/#tutorial-3-molecular-absorption-spectrum-rt-tddft-with-transform-flag","text":"Compute the absorption spectrum of a water molecule using three Dirac delta kicks. This uses multithreaded RT-TDDFT and Fourier transform. Prepare Input : Copy template-quantum.in . Enable transform for spectrum calculation. Example snippet: start general -- 'general' block wrappers are not necessary dt 0.1 -- au t_end 4000 -- au eField_path eField . csv end general -- rt-tddft portion start quantum start rttddft start geometry O 0.0000000000 0.0000000000 - 0.1302052882 H 1.4891244004 0.0000000000 1.0332262019 H - 1.4891244004 0.0000000000 1.0332262019 end geometry units bohr check_tolerance 1e-12 charge 0 spin 0 basis 6 - 31 g xc pbe0 resplimit 1e-20 propagator magnus2 pc_convergence 1e-12 maxiter 200 transform -- important to include this flag for abs spectrum simulation end rttddft start files start chkfile -- in case simulation crashes frequency 100 path chkfile . npz end chkfile pField_path pField . csv pField_Transform_path pField - transformed . npz eField_vs_pField_path output . png eV_spectrum_path spectrum . png -- this image will display the absorption spectrum end files start source shape kick -- needs to be a delta 'kick', not 'pulse' peak_time_au 0.1 width_steps 5 intensity_au 5e-5 -- dir z -- do not need to specify direction when transform flag used end source end quantum Run Simulation : python src/main.py -f /path/to/abs_spectrum.in -vv -l plasmol.log -r or python -m src.main -f /path/to/abs_spectrum.in -vv -l plasmol.log -r View Outputs : pField.csv : Induced dipole (polarization) data. spectrum.png : Absorption spectrum plot. Absorption spectrum run as compared to an LR-TDDFT standard from nwchem.","title":"Tutorial 3: Molecular Absorption Spectrum (RT-TDDFT with transform flag)"},{"location":"tutorials/#tutorial-4-full-plasmol-simulation-np-molecule","text":"Simulate a gold NP with a water molecule inside, tracking plasmon-molecule interactions. Prepare Input : Copy template-plasmol.in . Combine classical NP with quantum molecule. Example snippet: ```lua start general -- 'general' block wrappers are not necessary dt 0.1 -- au t_end 4000 -- au eField_path eField.csv end general -- rt-tddft portion start quantum start rttddft start geometry O 0.0000000000 0.0000000000 -0.1302052882 H 1.4891244004 0.0000000000 1.0332262019 H -1.4891244004 0.0000000000 1.0332262019 end geometry units bohr check_tolerance 1e-12 charge 0 spin 0 basis 6-31g xc pbe0 resplimit 1e-20 propagator magnus2 pc_convergence 1e-12 maxiter 200 transform -- important to include this flag for abs spectrum simulation end rttddft start files start chkfile -- in case simulation crashes frequency 100 path chkfile.npz end chkfile pField_path pField.csv pField_Transform_path pField-transformed.npz eField_vs_pField_path output.png eV_spectrum_path spectrum.png -- this image will display the absorption spectrum end files -- if source is given in quantum block but a classical block is found, -- this source will be ignored. -- start source -- shape kick -- peak_time_au 0.1 -- width_steps 5 -- intensity_au 5e-5 -- end source end quantum -- classical portion start classical start source sourceType continuous sourceCenter -0.04 sourceSize 0 0.1 0.1 frequency 5 end source start simulation cellLength 0.1 pmlThickness 0.01 -- spherical objects with an incident electric field propagating in the -- +y direction with a z electric component will have the following symmetry symmetries Y 1 Z -1 surroundingMaterialIndex 1.33 -- surrounds NP in water end simulation start object material Au radius 0.03 center 0 0 0 end object start hdf5 timestepsBetween 1 -- saves a picture every timestep intensityMin 3 intensityMax 10 imageDirName hello -- saves images to path hello/. end hdf5 end classical ``` Run Simulation : python src/main.py -f /path/to/plasmol.in -vv -l plasmol.log -r or python -m src.main -f /path/to/plasmol.in -vv -l plasmol.log -r View Outputs : Similar images, gifs, and spectra to the tutorials above can be found in this instance too. For SERS or other metrics, inject custom functions (see API Reference ). These tutorials cover basics\u2014experiment with parameters and check logs for issues. For advanced topics, see API Reference .","title":"Tutorial 4: Full PlasMol Simulation (NP + Molecule)"},{"location":"usage/","text":"Usage PlasMol is designed to be run from the command line, with most parameters specified in a single input file. This page explains how to create and structure an input file, as well as details on each supported block and parameter. For step-by-step examples, see the Tutorials page. General Process for Creating an Input File Determine Simulation Type : PlasMol supports three modes based on your input file: Classical Only : Simulate a nanoparticle (NP) using FDTD (via MEEP). Include a classical block but no quantum block. Quantum Only : Simulate a molecule using RT-TDDFT (via PySCF). Include a quantum block but no classical block. PlasMol (Full) : Simulate NP-molecule interactions. Include both classical and quantum blocks. Structure the Input File : The file uses a block-based format with start and end keywords. Comments start with # , -- , or % . Sections can be nested. Always start with a general or settings block (these two keywords are interchangeable) for shared parameters (e.g., time step, end time). Add classical and/or quantum blocks as needed. Use templates from the templates/ directory as starting points: template-classical.in template-quantum.in template-plasmol.in Run PlasMol : From the command line: python src/main.py -f /path/to/plasmol.in -vv -l plasmol.log -r or python -m src.main -f /path/to/plasmol.in -vv -l plasmol.log -r Common options: -v (verbose), -vv (debug), -l log.txt (log file), -r (restart, deletes old output files). See src/input/cli.py or run python src/main.py --help for full options. Output Files : PlasMol can generate CSVs (e.g., eField.csv , pField.csv ), images (e.g., via HDF5 or plots), and checkpoint files ( .npz ). For details, see the files block below. Units and Conventions : Times are in atomic units (au) unless specified. Coordinates are in Bohr or Angstrom (specify in units ). Electric fields are in au. Customization : For advanced tweaks (e.g., custom sources or propagators), modify the code as noted in API Reference . Input Blocks and Parameters Below are details on each block, drawn from the code and templates. Parameters are listed with defaults (if any), types, and descriptions. Required parameters are marked with *. General/Settings Block Shared simulation parameters. Use start general or start settings (interchangeable). This block is required. dt *: Float. Time step in au (e.g., 0.001 ). t_end *: Float. End time in au (e.g., 40 ). eField_path : String. Path to output CSV for electric field (e.g., eField.csv ). Example: start general dt 0.001 t_end 40 eField_path eField . csv end general Classical Block For NP simulations (FDTD via MEEP). Required for classical or full PlasMol modes. Source Sub-Block Defines the incident electric field. Required for most simulations. For more information about these sources, visit MEEP's documentation . sourceType *: String. One of: continuous , gaussian , chirped , pulse . sourceCenter *: Float or list (microns) (e.g., -0.04 or -0.04 0 0 ). Center position. If one component given, assumed in the 'x' direction. sourceSize *: List of 3 floats (microns) (e.g., 0 0.1 0.1 ). Size dimensions. frequency : Float. Frequency (au); mutually exclusive with wavelength . wavelength : Float. Wavelength (microns); mutually exclusive with frequency . width : Float (default 0). Gaussian width. fwidth : Float (default inf). Frequency width (alternative to width ). start_time : Float (default 0 or -inf). Start time. end_time : Float (default inf). End time. cutoff : Float (default 5.0, for Gaussian). Truncation cutoff. slowness : Float (default 3.0, for Continuous). Ramp-up slowness. peakTime : Float (for Chirped/Pulse). Peak time. chirpRate : Float (for Chirped). Chirp rate. is_integrated : Boolean (default True). Integrate source over time. component : String (default 'z'). Field component ('x', 'y', 'z'). Example (Continuous): start source sourceType continuous sourceCenter - 0.04 sourceSize 0 0.1 0.1 frequency 5 isIntegrated True end source Simulation Sub-Block Core FDTD parameters. For more information about these parameters, visit MEEP's documentation . cellLength *: Float (e.g., 0.1 ). Simulation cell size. pmlThickness *: Float (e.g., 0.01 ). PML boundary thickness. eFieldCutOff : Float (e.g., 1e-12 ). Threshold to trigger quantum propagation. Ignored if no quantum blocked defined. symmetries : List (e.g., Y 1 Z -1 ). Mirror symmetries (X/Y/Z with phase \u00b11). surroundingMaterialIndex : Float (default 1.0). Refractive index of medium. resolution : Float (optional). Spatial resolution; auto-calculated from dt if omitted. Example: start simulation cellLength 0.1 pmlThickness 0.01 eFieldCutOff 1e-12 symmetries Y 1 Z - 1 surroundingMaterialIndex 1.33 end simulation Object Sub-Block Defines the NP (currently supports spheres only). material *: String. Either Au or Ag . Material type. radius *: Float (microns) (e.g., 0.03 ). Sphere radius. center *: List of 3 floats (e.g., 0 0 0 ). Center position. Example: start object material Au radius 0.03 center 0 0 0 end object HDF5 Sub-Block For generating 2D cross-section images of the simulation. timestepsBetween *: Integer (e.g., 1 ). Interval for image output. intensityMin *: Float (e.g., 3 ). Min intensity for color scale. intensityMax *: Float (e.g., 10 ). Max intensity for color scale. imageDirName : String (optional, auto-generated if omitted). Output directory. Example: start hdf5 timestepsBetween 1 intensityMin 3 intensityMax 10 imageDirName images end hdf5 Molecule Sub-Block Places a molecule in the simulation (required for full PlasMol). center *: List of 3 floats (microns) (e.g., 0 0 0 ). Molecule position. Example: start molecule center 0 0 0 end molecule Quantum Block For molecule simulations (RT-TDDFT). Required for quantum or full PlasMol modes. RTTDDFT Sub-Block Core quantum parameters. Geometry sub-sub-block*: Atom coordinates. Inline after start geometry . units *: String ( bohr or angstrom ). check_tolerance : Float (default 1e-12). Tolerance for matrix checks for hermiticity. charge *: Integer (default 0). spin *: Integer (default 0). basis *: String (e.g., 6-31g ). xc *: String (e.g., pbe0 ). Exchange-correlation functional. propagator *: String, one of step , rk4 , or magnus2 . pc_convergence : Float (only for magnus2, e.g., 1e-12 ). maxiter : Integer (only for magnus2, e.g., 200 ). transform : (No value needed). Enables absorption spectrum calculation. See the API Reference and Tutorial #3 for more details. Example: start rttddft start geometry O 0.0 0.0 - 0.13 H 1.49 0.0 1.03 H - 1.49 0.0 1.03 end geometry units bohr basis 6 - 31 g xc pbe0 propagator magnus2 transform end rttddft Files Sub-Block Output paths. chkfile sub-sub-block: frequency int (e.g., 100 ). Number of time steps between checkpoints. path string (e.g., chkfile.npz ). Path to checkpoint file. pField_path : String (e.g., pField.csv ). Polarization field CSV. eField_vs_pField_path : String (e.g., output.png ). Plot of fields. pField_Transform_path : String (e.g., pField-transformed.npz ). Transformed data (for spectrum). eV_spectrum_path : String (e.g., spectrum.png ). Absorption spectrum plot. Example: start files start chkfile frequency 100 path chkfile . npz end chkfile pField_path pField . csv end files Source Sub-Block (Quantum-Only) Electric field for standalone quantum simulations. shape *: String ( pulse or kick ). wavelength_nm : Float (for pulse). peak_time_au : Float. width_steps : Integer. intensity_au : Float. dir : String ( x , y , z ). Example: start source shape pulse wavelength_nm 500 peak_time_au 0.1 width_steps 5 intensity_au 5e-5 dir z end source For more details on code internals, see API Reference .","title":"Usage"},{"location":"usage/#usage","text":"PlasMol is designed to be run from the command line, with most parameters specified in a single input file. This page explains how to create and structure an input file, as well as details on each supported block and parameter. For step-by-step examples, see the Tutorials page.","title":"Usage"},{"location":"usage/#general-process-for-creating-an-input-file","text":"Determine Simulation Type : PlasMol supports three modes based on your input file: Classical Only : Simulate a nanoparticle (NP) using FDTD (via MEEP). Include a classical block but no quantum block. Quantum Only : Simulate a molecule using RT-TDDFT (via PySCF). Include a quantum block but no classical block. PlasMol (Full) : Simulate NP-molecule interactions. Include both classical and quantum blocks. Structure the Input File : The file uses a block-based format with start and end keywords. Comments start with # , -- , or % . Sections can be nested. Always start with a general or settings block (these two keywords are interchangeable) for shared parameters (e.g., time step, end time). Add classical and/or quantum blocks as needed. Use templates from the templates/ directory as starting points: template-classical.in template-quantum.in template-plasmol.in Run PlasMol : From the command line: python src/main.py -f /path/to/plasmol.in -vv -l plasmol.log -r or python -m src.main -f /path/to/plasmol.in -vv -l plasmol.log -r Common options: -v (verbose), -vv (debug), -l log.txt (log file), -r (restart, deletes old output files). See src/input/cli.py or run python src/main.py --help for full options. Output Files : PlasMol can generate CSVs (e.g., eField.csv , pField.csv ), images (e.g., via HDF5 or plots), and checkpoint files ( .npz ). For details, see the files block below. Units and Conventions : Times are in atomic units (au) unless specified. Coordinates are in Bohr or Angstrom (specify in units ). Electric fields are in au. Customization : For advanced tweaks (e.g., custom sources or propagators), modify the code as noted in API Reference .","title":"General Process for Creating an Input File"},{"location":"usage/#input-blocks-and-parameters","text":"Below are details on each block, drawn from the code and templates. Parameters are listed with defaults (if any), types, and descriptions. Required parameters are marked with *.","title":"Input Blocks and Parameters"},{"location":"usage/#generalsettings-block","text":"Shared simulation parameters. Use start general or start settings (interchangeable). This block is required. dt *: Float. Time step in au (e.g., 0.001 ). t_end *: Float. End time in au (e.g., 40 ). eField_path : String. Path to output CSV for electric field (e.g., eField.csv ). Example: start general dt 0.001 t_end 40 eField_path eField . csv end general","title":"General/Settings Block"},{"location":"usage/#classical-block","text":"For NP simulations (FDTD via MEEP). Required for classical or full PlasMol modes.","title":"Classical Block"},{"location":"usage/#source-sub-block","text":"Defines the incident electric field. Required for most simulations. For more information about these sources, visit MEEP's documentation . sourceType *: String. One of: continuous , gaussian , chirped , pulse . sourceCenter *: Float or list (microns) (e.g., -0.04 or -0.04 0 0 ). Center position. If one component given, assumed in the 'x' direction. sourceSize *: List of 3 floats (microns) (e.g., 0 0.1 0.1 ). Size dimensions. frequency : Float. Frequency (au); mutually exclusive with wavelength . wavelength : Float. Wavelength (microns); mutually exclusive with frequency . width : Float (default 0). Gaussian width. fwidth : Float (default inf). Frequency width (alternative to width ). start_time : Float (default 0 or -inf). Start time. end_time : Float (default inf). End time. cutoff : Float (default 5.0, for Gaussian). Truncation cutoff. slowness : Float (default 3.0, for Continuous). Ramp-up slowness. peakTime : Float (for Chirped/Pulse). Peak time. chirpRate : Float (for Chirped). Chirp rate. is_integrated : Boolean (default True). Integrate source over time. component : String (default 'z'). Field component ('x', 'y', 'z'). Example (Continuous): start source sourceType continuous sourceCenter - 0.04 sourceSize 0 0.1 0.1 frequency 5 isIntegrated True end source","title":"Source Sub-Block"},{"location":"usage/#simulation-sub-block","text":"Core FDTD parameters. For more information about these parameters, visit MEEP's documentation . cellLength *: Float (e.g., 0.1 ). Simulation cell size. pmlThickness *: Float (e.g., 0.01 ). PML boundary thickness. eFieldCutOff : Float (e.g., 1e-12 ). Threshold to trigger quantum propagation. Ignored if no quantum blocked defined. symmetries : List (e.g., Y 1 Z -1 ). Mirror symmetries (X/Y/Z with phase \u00b11). surroundingMaterialIndex : Float (default 1.0). Refractive index of medium. resolution : Float (optional). Spatial resolution; auto-calculated from dt if omitted. Example: start simulation cellLength 0.1 pmlThickness 0.01 eFieldCutOff 1e-12 symmetries Y 1 Z - 1 surroundingMaterialIndex 1.33 end simulation","title":"Simulation Sub-Block"},{"location":"usage/#object-sub-block","text":"Defines the NP (currently supports spheres only). material *: String. Either Au or Ag . Material type. radius *: Float (microns) (e.g., 0.03 ). Sphere radius. center *: List of 3 floats (e.g., 0 0 0 ). Center position. Example: start object material Au radius 0.03 center 0 0 0 end object","title":"Object Sub-Block"},{"location":"usage/#hdf5-sub-block","text":"For generating 2D cross-section images of the simulation. timestepsBetween *: Integer (e.g., 1 ). Interval for image output. intensityMin *: Float (e.g., 3 ). Min intensity for color scale. intensityMax *: Float (e.g., 10 ). Max intensity for color scale. imageDirName : String (optional, auto-generated if omitted). Output directory. Example: start hdf5 timestepsBetween 1 intensityMin 3 intensityMax 10 imageDirName images end hdf5","title":"HDF5 Sub-Block"},{"location":"usage/#molecule-sub-block","text":"Places a molecule in the simulation (required for full PlasMol). center *: List of 3 floats (microns) (e.g., 0 0 0 ). Molecule position. Example: start molecule center 0 0 0 end molecule","title":"Molecule Sub-Block"},{"location":"usage/#quantum-block","text":"For molecule simulations (RT-TDDFT). Required for quantum or full PlasMol modes.","title":"Quantum Block"},{"location":"usage/#rttddft-sub-block","text":"Core quantum parameters. Geometry sub-sub-block*: Atom coordinates. Inline after start geometry . units *: String ( bohr or angstrom ). check_tolerance : Float (default 1e-12). Tolerance for matrix checks for hermiticity. charge *: Integer (default 0). spin *: Integer (default 0). basis *: String (e.g., 6-31g ). xc *: String (e.g., pbe0 ). Exchange-correlation functional. propagator *: String, one of step , rk4 , or magnus2 . pc_convergence : Float (only for magnus2, e.g., 1e-12 ). maxiter : Integer (only for magnus2, e.g., 200 ). transform : (No value needed). Enables absorption spectrum calculation. See the API Reference and Tutorial #3 for more details. Example: start rttddft start geometry O 0.0 0.0 - 0.13 H 1.49 0.0 1.03 H - 1.49 0.0 1.03 end geometry units bohr basis 6 - 31 g xc pbe0 propagator magnus2 transform end rttddft","title":"RTTDDFT Sub-Block"},{"location":"usage/#files-sub-block","text":"Output paths. chkfile sub-sub-block: frequency int (e.g., 100 ). Number of time steps between checkpoints. path string (e.g., chkfile.npz ). Path to checkpoint file. pField_path : String (e.g., pField.csv ). Polarization field CSV. eField_vs_pField_path : String (e.g., output.png ). Plot of fields. pField_Transform_path : String (e.g., pField-transformed.npz ). Transformed data (for spectrum). eV_spectrum_path : String (e.g., spectrum.png ). Absorption spectrum plot. Example: start files start chkfile frequency 100 path chkfile . npz end chkfile pField_path pField . csv end files","title":"Files Sub-Block"},{"location":"usage/#source-sub-block-quantum-only","text":"Electric field for standalone quantum simulations. shape *: String ( pulse or kick ). wavelength_nm : Float (for pulse). peak_time_au : Float. width_steps : Integer. intensity_au : Float. dir : String ( x , y , z ). Example: start source shape pulse wavelength_nm 500 peak_time_au 0.1 width_steps 5 intensity_au 5e-5 dir z end source For more details on code internals, see API Reference .","title":"Source Sub-Block (Quantum-Only)"}]}