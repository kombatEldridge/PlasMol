// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/__init__.py
# __init__.py
__version__ = "1.0.0"  
__author__ = "Brinton King Eldridge" 

from .drivers import *



// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/classical/__init__.py
# classical/__init__.py
from .simulation import Simulation
from .sources import ContinuousSource, GaussianSource, ChirpedSource, PulseSource

__all__ = ['Simulation', 'ContinuousSource', 'GaussianSource', 'ChirpedSource', 'PulseSource']

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/classical/simulation.py
# classical/simulation.py
import logging
import meep as mp
import numpy as np
import matplotlib.pyplot as plt
from collections import defaultdict

from .. import constants
from ..utils.csv import updateCSV
from ..quantum.propagators import *
from ..quantum.propagation import propagation

class Simulation:
    def __init__(self, params, molecule=None):
        self.params = params
    
        self.dt_meep = self.params.dt / constants.convertTimeMeep2Atomic
        self.t_end_meep = self.params.t_end / constants.convertTimeMeep2Atomic

        # Define simulation parameters
        self.cellLength = self.params.simulation_params['cellLength']
        self.pmlThickness = self.params.simulation_params['pmlThickness']
        self.resolution = self.params.simulation_params['resolution']
        self.eFieldCutOff = self.params.simulation_params['eFieldCutOff']

        logging.debug(f"Initializing simulation with cellLength: {self.cellLength}, resolution: {self.resolution}")
        
        self.moleculeBool = True if self.params.molecule_position else False
        self.positionMolecule = mp.Vector3(
            self.params.molecule_position['center'][0],
            self.params.molecule_position['center'][1],
            self.params.molecule_position['center'][2]) if self.moleculeBool else None
        
        if self.moleculeBool:
            self.molecule = molecule
            if self.params.propagator == "step":
                self.propagate = propagate_step
            elif self.params.propagator == "magnus2":
                self.propagate = propagate_magnus2
            elif self.params.propagator == "rk4":
                self.propagate = propagate_rk4
        
        self.hdf5Bool = True if params.hdf5 else None
        self.imageDirName = params.hdf5['imageDirName'] if self.hdf5Bool else None
        self.timestepsBetween = params.hdf5['timestepsBetween'] if self.hdf5Bool else None
        self.intensityMin = params.hdf5['intensityMin'] if self.hdf5Bool else None
        self.intensityMax = params.hdf5['intensityMax'] if self.hdf5Bool else None

        # Simulation runtime variables
        self.xyz = ['x', 'y', 'z']
        self.measuredDipoleResponse = {component: defaultdict(list) for component in self.xyz}
        self.mapDirectionToDigit = {'x': 0, 'y': 1, 'z': 2}
        self.char_to_field = {'x': mp.Ex, 'y': mp.Ey, 'z': mp.Ez}
        self.decimalPlaces = None
        self.cellVolume = mp.Vector3(self.cellLength, self.cellLength, self.cellLength)
        self.frameCenter = self.cellLength * self.resolution / 2

        self.sourcesList = []
        if self.moleculeBool:
            self.sourcesList.append(
                mp.Source(
                    mp.CustomSource(src_func=self.chirpx,is_integrated=True),
                    center=self.positionMolecule,
                    component=mp.Ex
                )
            )
            self.sourcesList.append(
                mp.Source(
                    mp.CustomSource(src_func=self.chirpy,is_integrated=True),
                    center=self.positionMolecule,
                    component=mp.Ey
                )
            )
            self.sourcesList.append(
                mp.Source(
                    mp.CustomSource(src_func=self.chirpz,is_integrated=True),
                    center=self.positionMolecule,
                    component=mp.Ez
                )
            )
            logging.debug("Emitter for the molecule added to simulation")
        
        self.source = self.params.source
        if self.source is not None:
            self.sourcesList.append(self.source.source)

        self.pmlList = [mp.PML(thickness=self.pmlThickness)]
        self.symmetry = self.params.symmetry
        self.nanoparticle = [self.params.nanoparticle] if self.params.nanoparticle is not None else []
        self.default_material = mp.Medium(index=self.params.simulation_params['surroundingMaterialIndex'])

        self.sim = mp.Simulation(
            resolution=self.resolution,
            cell_size=self.cellVolume,
            boundary_layers=self.pmlList,
            sources=self.sourcesList,
            symmetries=self.symmetry,
            geometry=self.nanoparticle,
            default_material=self.default_material
        )

        # Determine the number of decimal places for time steps
        halfTimeStepString = str(self.params.dt / 2)
        self.decimalPlaces = len(halfTimeStepString.split('.')[1])

    def chirpx(self, t):
        """
        Chirp function for the x-component of the dipole response.
        CustomSource with isIntegrated=True expects Polarization density
        https://github.com/NanoComp/meep/discussions/2809#discussioncomment-8929239
        """
        logging.debug(f"chirpx being called at {round(t * constants.convertTimeMeep2Atomic, self.decimalPlaces)} au. Emitting {self.measuredDipoleResponse['x'].get(str(round(t, self.decimalPlaces)), 0) * constants.convertFieldMeep2Atomic} in au.")
        return self.measuredDipoleResponse['x'].get(str(round(t, self.decimalPlaces)), 0) * constants.convertMomentAtomic2Meep

    def chirpy(self, t):
        """
        Chirp function for the y-component of the dipole response.
        CustomSource with isIntegrated=True expects Polarization density
        https://github.com/NanoComp/meep/discussions/2809#discussioncomment-8929239
        """
        logging.debug(f"chirpy being called at {round(t * constants.convertTimeMeep2Atomic, self.decimalPlaces)} au. Emitting {self.measuredDipoleResponse['y'].get(str(round(t, self.decimalPlaces)), 0) * constants.convertFieldMeep2Atomic} in au.")
        return self.measuredDipoleResponse['y'].get(str(round(t, self.decimalPlaces)), 0) * constants.convertMomentAtomic2Meep

    def chirpz(self, t):
        """
        Chirp function for the z-component of the dipole response.
        CustomSource with isIntegrated=True expects Polarization density
        https://github.com/NanoComp/meep/discussions/2809#discussioncomment-8929239
        """
        logging.debug(f"chirpz being called at {round(t * constants.convertTimeMeep2Atomic, self.decimalPlaces)} au. Emitting {self.measuredDipoleResponse['z'].get(str(round(t, self.decimalPlaces)), 0) * constants.convertFieldMeep2Atomic} in au.")
        return self.measuredDipoleResponse['z'].get(str(round(t, self.decimalPlaces)), 0) * constants.convertMomentAtomic2Meep

    def callPropagation(self, sim):
        """
        Calls Quantum calculations if the electric field exceeds the response cutoff.

        Args:
            sim (mp.Simulation): The Meep simulation object.
        """
        logging.info(f"Getting Electric Field at the molecule at time {round(sim.meep_time() * constants.convertTimeMeep2Atomic, 4)} au")
        eField = {component: [] for component in self.xyz}
        for componentName in self.xyz:
            field = np.mean(sim.get_array(component=self.char_to_field[componentName],
                                          center=self.positionMolecule,
                                          size=mp.Vector3(1E-20, 1E-20, 1E-20)))
            eField[componentName] = field * constants.convertFieldMeep2Atomic

        if any(abs(eField[component]) >= self.eFieldCutOff for component in self.xyz):
            logging.info(f"Calling propagator at time {round(sim.meep_time() * constants.convertTimeMeep2Atomic, 4)} au")

            eArr = [eField['x'],eField['y'],eField['z']]
            logging.debug(f'Electric field given to propagator: {eArr} in au')
            
            ind_dipole = propagation(self.params, self.molecule, eArr, self.propagate)

            logging.debug(f"Propagation calculation results: {ind_dipole} in au")
            
            for componentName in self.xyz:
                for offset in [0.5 * self.dt_meep, self.dt_meep]:
                    timestamp = str(round(sim.meep_time() + offset, self.decimalPlaces))
                    self.measuredDipoleResponse[componentName][timestamp] = ind_dipole[self.mapDirectionToDigit[componentName]]

            timestamp = str(round((sim.meep_time() + self.dt_meep) * constants.convertTimeMeep2Atomic, self.decimalPlaces))
            updateCSV(self.params.pField_path, timestamp, ind_dipole[0], ind_dipole[1], ind_dipole[2])

        timestamp = str(round((sim.meep_time() + self.dt_meep) * constants.convertTimeMeep2Atomic, self.decimalPlaces))
        updateCSV(self.params.eField_path, timestamp, eField['x'], eField['y'], eField['z'])

    # ------------------------------------ #
    #              Additional              #
    #      custom tracking functions       #
    #          can be defined here         #
    #     similar to callPropagation()     #
    #   and added to the simulation loop   #
    #          as commented below          #
    #                                      #
    #     i.e. getElectricField() does     #
    #   the same as callPropagation() but  #
    #    without calling the propagation   #
    # ------------------------------------ #
    # def getElectricField(self, sim):
    #     """
    #     Retrieves the electric field values at the molecule's position during the simulation.

    #     Args:
    #         sim (mp.Simulation): The Meep simulation object.
    #     """
    #     logging.info(f"Getting Electric Field at the molecule at time {round(sim.meep_time() * constants.convertTimeMeep2Atomic, 4)} au")
    #     eField = {component: [] for component in self.xyz}
    #     for componentName in self.xyz:
    #         field = np.mean(sim.get_array(component=self.char_to_field[componentName],
    #                                       center=self.positionMolecule,
    #                                       size=mp.Vector3(1E-20, 1E-20, 1E-20)))
    #         eField[componentName] = field * constants.convertFieldMeep2Atomic

    #     timestamp = str(round((sim.meep_time() + self.dt_meep) * constants.convertTimeMeep2Atomic, self.decimalPlaces))
    #     updateCSV(self.params.eField_path, timestamp, eField['x'], eField['y'], eField['z'])



    def run(self):
        """
        Runs the Meep simulation and generates a GIF of the electric field evolution.
        """
        logging.info("Meep simulation started.")
        if self.hdf5Bool:
            from ..utils.gif import clear_directory
            clear_directory(self.imageDirName)
            self.sim.use_output_directory(self.imageDirName)

        try:
            run_functions = []
            if self.hdf5Bool:
                run_functions.append(mp.at_every(self.timestepsBetween * self.dt_meep, mp.output_png(mp.Ez, f"-X 10 -Y 10 -m {self.intensityMin} -M {self.intensityMax} -z {self.frameCenter} -Zc dkbluered")))
            if self.moleculeBool:
                run_functions.append(mp.at_every(self.dt_meep, self.callPropagation))
            # ------------------------------------ #
            #              Additional              #
            #      custom tracking functions       #
            #           can be added here          #
            # ------------------------------------ #

            self.sim.run(*run_functions, until=self.t_end_meep)
            # show3Dmap(self.sim)
            # show2Dmap(self.sim)

            logging.info("Simulation completed successfully!")
        except Exception as e:
            logging.error(f"Simulation failed with error: {e}", exc_info=True)
        finally:
            if self.hdf5Bool:
                from ..utils.gif import make_gif
                make_gif(self.imageDirName)
                import os 
                os.chdir('../')

# ------------------------------------ #
#         Example custom block         #
#         to show 3D map of NP         #
# ------------------------------------ #
def show3Dmap(sim):
    import plotly.graph_objects as go
    eps_data = sim.get_array(center=mp.Vector3(), size=self.cellVolume, component=mp.Dielectric)
    nx, ny, nz = eps_data.shape
    x, y, z = np.mgrid[0:nx, 0:ny, 0:nz]
    iso_value = 4
    fig = go.Figure(data=go.Isosurface(
        x=x.flatten(),
        y=y.flatten(),
        z=z.flatten(),
        value=eps_data.flatten(),
        isomin=iso_value,
        isomax=iso_value,
        colorscale=[[0, 'gold'], [1, 'gold']],
        showscale=False,
        opacity=0.8,
        caps=dict(x_show=False, y_show=False, z_show=False)
    ))
    fig.show()

# ------------------------------------ #
#         Example custom block         #
#         to show 2D map of NP         #
# ------------------------------------ #
def show2Dmap(sim):
    import plotly.graph_objects as go
    import numpy as np
    eps_data = sim.get_array(center=mp.Vector3(), size=sim.cell_size, component=mp.Dielectric)
    nx, ny, nz = eps_data.shape
    z_mid = nz // 2
    eps_slice = eps_data[:, :, z_mid]
    iso_value = 4
    # Binary mask: 1 where >= iso_value (dielectric), 0 otherwise
    z_plot = np.where(eps_slice >= iso_value, 1, 0)
    fig = go.Figure(data=go.Heatmap(
        z=z_plot,
        colorscale=[[0, 'white'], [1, 'black']],
        showscale=False
    ))
    fig.update_layout(
        title='2D Slice of Dielectric (XY plane at Z midpoint)',
        xaxis_title='X',
        yaxis_title='Y',
        yaxis=dict(scaleanchor='x')  # Make aspect ratio square
    )
    fig.show()

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/classical/sources.py
# classical/sources.py
import logging
import meep as mp
import numpy as np

class ContinuousSource:
    def __init__(self,
                 sourceCenter,
                 sourceSize,
                 frequency=None,
                 wavelength=None,
                 start_time=0,
                 end_time=1e+20,
                 width=0,
                 fwidth=float("inf"),
                 slowness=3.0,
                 is_integrated=True,
                 component='z'):
        """
        Initializes a ContinuousSource object.

        Args:
            frequency (float): The frequency of the continuous source.
            sourceCenter (tuple): The center coordinates of the source.
            sourceSize (tuple): The size dimensions of the source.
            is_integrated (bool): If True, integrates the source over time.
            component (mp.Vector3): The component of the electric field for the source.
        """
        logging.debug(f"Initializing ContinuousSource")

        char_to_field = {'x': mp.Ex, 'y': mp.Ey, 'z': mp.Ez}
        self.component = char_to_field[component]
        self.sourceCenter = mp.Vector3(sourceCenter)
        self.sourceSize = mp.Vector3(sourceSize[0], sourceSize[1], sourceSize[2])
        kwargs = {
            'frequency': 1 / wavelength if wavelength else float(frequency),
            'is_integrated': is_integrated,
            'start_time': start_time,
            'end_time': end_time,
            'width': max(width, 1 / fwidth) if fwidth not in [None, float("inf")] else width,
            'slowness': slowness,
        }
        filtered_kwargs = {k: v for k, v in kwargs.items() if v is not None}
        self.source = mp.Source(
            mp.ContinuousSource(**filtered_kwargs),
            component=self.component,
            center=self.sourceCenter,
            size=self.sourceSize,
        )


class GaussianSource:
    def __init__(self,
                 sourceCenter,
                 sourceSize,
                 frequency=None,
                 wavelength=None,
                 width=0,
                 fwidth=float("inf"),
                 start_time=0,
                 cutoff=5.0,
                 is_integrated=True,
                 component='z'):
        """
        Initializes a GaussianSource object.

        Args:
            frequencyCenter (float): The center frequency of the Gaussian source.
            width (float): The width of the Gaussian source in wavelengths.
            fwidth (float): The width of the Gaussian source in frequency.
            sourceCenter (tuple): The center coordinates of the source.
            sourceSize (tuple): The size dimensions of the source.
            is_integrated (bool): If True, integrates the source over time.
            component (mp.Vector3): The component of the electric field for the source.
        """
        logging.debug(f"Initializing GaussianSource")
        
        char_to_field = {'x': mp.Ex, 'y': mp.Ey, 'z': mp.Ez}
        self.component = char_to_field[component]
        self.sourceCenter = mp.Vector3(sourceCenter)
        self.sourceSize = mp.Vector3(sourceSize[0], sourceSize[1], sourceSize[2])
        kwargs = {
            'frequency': 1 / wavelength if wavelength else float(frequency),
            'width': max(width, 1 / fwidth) if fwidth not in [None, float("inf")] else width,
            'start_time': start_time,
            'cutoff': cutoff,
            'is_integrated': is_integrated,
        }
        filtered_kwargs = {k: v for k, v in kwargs.items() if v is not None}
        self.source = mp.Source(
            mp.GaussianSource(**filtered_kwargs),
            component=self.component,
            center=self.sourceCenter,
            size=self.sourceSize,
        )


class ChirpedSource:
    def __init__(self,
                 sourceCenter,
                 sourceSize,
                 frequency=1,
                 wavelength=None,
                 width=0.2,
                 peakTime=15,
                 chirpRate=-0.5,
                 start_time=-1e20,
                 end_time=1e20,
                 is_integrated=True,
                 component='z'):
        """
        Initializes a ChirpedSource object.

        Args:
            frequency (float): The frequency of the pulse source in units of 1/wavelength.
            wavelength (float): The wavelength of the pulse in microns.
            width (float): The width of the pulse source in 1/fs**2.
            peakTime (float): The time at which the pulse is maximum in fs.
            sourceCenter (tuple): The center coordinates of the source.
            sourceSize (tuple): The size dimensions of the source.
            is_integrated (bool): If True, integrates the source over time.
            component (mp.Vector3): The component of the electric field for the source.
        """
        logging.debug(f"Initializing ChirpedSource")
        char_to_field = {'x': mp.Ex, 'y': mp.Ey, 'z': mp.Ez}
        self.component = char_to_field[component]
        self.conversionFactor = 3.378555833184493 # from many tests in PulseTest
        self.sourceCenter = mp.Vector3(sourceCenter)
        self.sourceSize = mp.Vector3(sourceSize[0], sourceSize[1], sourceSize[2])
        kwargs = {
            'start_time': start_time,
            'end_time': end_time,
            'is_integrated': is_integrated,
        }
        filtered_kwargs = {k: v for k, v in kwargs.items() if v is not None}

        frequency = 1/wavelength if wavelength else (frequency * 2.99792458e8 * 1e6 * self.conversionFactor * 1e-15)
        peakTime = peakTime * (1/self.conversionFactor)
        width = width * (self.conversionFactor**2)
        chirpRate = chirpRate * (self.conversionFactor**2)
        func = lambda t: np.exp(1j * 2 * np.pi * frequency * (t - peakTime)) * np.exp(-width * (t - peakTime) ** 2 + 1j * chirpRate * (t - peakTime) ** 2)

        self.source = mp.Source(
            src=mp.CustomSource(src_func=func, **filtered_kwargs),
            component=self.component,
            center=self.sourceCenter,
            size=self.sourceSize,
        )


class PulseSource:
    def __init__(self,
                 sourceCenter,
                 sourceSize,
                 frequency=0.6,
                 wavelength=None,
                 width=0.01,
                 peakTime=30,
                 start_time=-1e20,
                 end_time=1e20,
                 is_integrated=True,
                 component='z'):
        """
        Initializes a PulseSource object.

        Args:
            frequency (float): The frequency of the pulse source in units of 1/wavelength.
            wavelength (float): The wavelength of the pulse in microns.
            width (float): The width of the pulse source in 1/fs**2.
            peakTime (float): The time at which the pulse is maximum in fs.
            sourceCenter (tuple): The center coordinates of the source.
            sourceSize (tuple): The size dimensions of the source.
            is_integrated (bool): If True, integrates the source over time.
            component (mp.Vector3): The component of the electric field for the source.
        """
        logging.debug(f"Initializing PulseSource")

        char_to_field = {'x': mp.Ex, 'y': mp.Ey, 'z': mp.Ez}
        self.component = char_to_field[component]
        self.conversionFactor = 3.378555833184493 # from many tests in PulseTest
        self.sourceCenter = mp.Vector3(sourceCenter)
        self.sourceSize = mp.Vector3(sourceSize[0], sourceSize[1], sourceSize[2])
        kwargs = {
            'start_time': start_time,
            'end_time': end_time,
            'is_integrated': is_integrated,
        }
        filtered_kwargs = {k: v for k, v in kwargs.items() if v is not None}
        frequency = 1/wavelength if wavelength else (frequency * 2.99792458e8 * 1e6 * self.conversionFactor * 1e-15)
        peakTime = peakTime * (1/self.conversionFactor)
        width = width * (self.conversionFactor**2)
        func = lambda t: np.exp(1j * 2 * np.pi * frequency * (t - peakTime)) * np.exp(-width * (t - peakTime) ** 2)

        self.source = mp.Source(
            src=mp.CustomSource(src_func=func, **filtered_kwargs),
            component=self.component,
            center=self.sourceCenter,
            size=self.sourceSize,
        )


# ------------------------------------ #
#          Additional custom           #
#         classes for sources          #
#          can be added here           #
#        and need to be added to       #
#   the `input/params.py` file under   #
#       the `getSource()` method       #
# ------------------------------------ #







// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/constants.py
# constants.py
c = 299792458.0
epsilon_0 = 8.8541878128e-12
angs2bohr = 1.0/0.52917721067

convertTimeMeep2fs = 10 / 3
convertTimeAtomic2fs = 0.024188843
convertMomentAtomic2Meep = 8.4783536198e-30 * c / 1 / 1e-6 / 1e-6
convertTimeMeep2Atomic = convertTimeMeep2fs / convertTimeAtomic2fs
convertFieldMeep2Atomic = 1 / 1e-6 / epsilon_0 / c / 0.51422082e12

A0 = 5.29177210903e-11  # Bohr radius in m
C_AU = 137.035999       # Speed of light in atomic units
D_AU_NM = 1e-9 / A0     # Distance conv in au/nm
T_AU_FS = 41.3413733    # Time conv in au/fs
V_AU_AA3 = 0.14818471    # Volume conv in au/Å³

vdw_radii = {'H': 1.2, 'He': 1.4, 'Li': 2.2, 'Be': 1.9, 'B': 1.8, 'C': 1.7, 'N': 1.6, 'O': 1.55, 'F': 1.5, 
             'Ne': 1.54, 'Na': 2.4, 'Mg': 2.2, 'Al': 2.1, 'Si': 2.1, 'P': 1.95, 'S': 1.8, 'Cl': 1.8, 'Ar': 1.88, 
             'K': 2.8, 'Ca': 2.4, 'Sc': 2.3, 'Ti': 2.15, 'V': 2.05, 'Cr': 2.05, 'Mn': 2.05, 'Fe': 2.05, 'Co': 2.0, 
             'Ni': 2.0, 'Cu': 2.0, 'Zn': 2.1, 'Ga': 2.1, 'Ge': 2.1, 'As': 2.05, 'Se': 1.9, 'Br': 1.9, 'Kr': 2.02, 
             'Rb': 2.9, 'Sr': 2.55, 'Y': 2.4, 'Zr': 2.3, 'Nb': 2.15, 'Mo': 2.1, 'Tc': 2.05, 'Ru': 2.05, 'Rh': 2.0, 
             'Pd': 2.05, 'Ag': 2.1, 'Cd': 2.2, 'In': 2.2, 'Sn': 2.25, 'Sb': 2.2, 'Te': 2.1, 'I': 2.1, 'Xe': 2.16, 
             'Cs': 3.0, 'Ba': 2.7, 'La': 2.5, 'Ce': 2.48, 'Pr': 2.47, 'Nd': 2.45, 'Pm': 2.43, 'Sm': 2.42, 'Eu': 2.4, 
             'Gd': 2.38, 'Tb': 2.37, 'Dy': 2.35, 'Ho': 2.33, 'Er': 2.32, 'Tm': 2.3, 'Yb': 2.28, 'Lu': 2.27, 'Hf': 2.25, 
             'Ta': 2.2, 'W': 2.1, 'Re': 2.05, 'Os': 2.0, 'Ir': 2.0, 'Pt': 2.05, 'Au': 2.1, 'Hg': 2.05, 'Tl': 2.2, 
             'Pb': 2.3, 'Bi': 2.3, 'Po': 2.0, 'At': 2.0, 'Rn': 2.0, 'Fr': 2.0, 'Ra': 2.0, 'Ac': 2.0, 'Th': 2.4, 
             'Pa': 2.0, 'U': 2.3, 'Np': 2.0, 'Pu': 2.0, 'Am': 2.0, 'Cm': 2.0, 'Bk': 2.0, 'Cf': 2.0, 'Es': 2.0, 
             'Fm': 2.0, 'Md': 2.0, 'No': 2.0, 'Lr': 2.0, 'Rf': 2.0, 'Db': 2.0, 'Sg': 2.0, 'Bh': 2.0, 'Hs': 2.0, 
             'Mt': 2.0, 'Ds': 2.0, 'Rg': 2.0, 'Cn': 2.0, 'Nh': 2.0, 'Fl': 2.0, 'Mc': 2.0, 'Lv': 2.0, 'Ts': 2.0, 'Og': 2.0}


// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/drivers/__init__.py
# drivers/__init__.py
from .classical import run as run_classical
from .plasmol import run as run_plasmol
from .quantum import run as run_quantum

__all__ = ['run_classical', 'run_plasmol', 'run_quantum']  # Controls 'from drivers import *'

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/drivers/classical.py
# drivers/classical.py
import os
import sys
import logging
from ..classical.simulation import Simulation

def run(params):
    try:
        logger = logging.getLogger("main")
                
        simDriver = Simulation(params)
        simDriver.run()
        
        logging.info("Simulation completed successfully.")
    except Exception as err:
        logger.error(f"Simulation failed: {err}", exc_info=True)
        sys.exit(1)

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/drivers/plasmol.py
# drivers/plasmol.py
import os
import sys
import logging

from ..classical.simulation import Simulation
from ..quantum.molecule import MOLECULE
from ..utils.plotting import show_eField_pField
from ..utils.csv import initCSV, read_field_csv

def run(params):
    try:
        logger = logging.getLogger("main")
        
        molecule = MOLECULE(params)

        if params.chkfile_path is not None and os.path.exists(params.chkfile_path):
            try:
                _ = read_field_csv(params.eField_path)
                _ = read_field_csv(params.pField_path)
                logger.debug(f"Checkpoint file {params.chkfile_path} found as well as properly formatted field fields: {params.eField_path} and {params.pField_path}. Skipping electric/polarizability file generation.")
            except Exception as e:
                print(f"Error reading file: {e}")
        else:            
            initCSV(params.eField_path, "Electric Field intensity in atomic units")
            initCSV(params.pField_path, "Molecule's Polarizability Field intensity in atomic units")
            logger.debug(f"Field files successfully initialized: {params.eField_path} and {params.pField_path}")
        
        simDriver = Simulation(params, molecule)
        simDriver.run()
        
        # Plot the results using the interpolated electric field data
        show_eField_pField(params.eField_path, params.pField_path)
        logging.info("Simulation completed successfully.")
    except Exception as err:
        logger.error(f"Simulation failed: {err}", exc_info=True)
        sys.exit(1)

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/drivers/quantum.py
# drivers/quantum.py
import os
import sys
import csv
import copy
import logging
import threading
import numpy as np

from ..quantum.molecule import MOLECULE
from ..quantum.electric_field import ELECTRICFIELD

from ..quantum.propagators import *
from ..quantum.propagation import propagation
from ..quantum.chkfile import update_chkfile

from ..utils.fourier import transform
from ..utils.plotting import show_eField_pField
from ..utils.csv import initCSV, updateCSV, read_field_csv

def run(params):
    """Run the RT-TDDFT computation, either single-threaded or multi-threaded based on params.transform."""
    def run_computation(params_instance):
        """Execute the core RT-TDDFT computation for a given params object."""
        try:
            logger = logging.getLogger("main")

            time_values = np.arange(0, params_instance.t_end + params_instance.dt, params_instance.dt)
            times = np.linspace(0, time_values[-1], int(len(time_values)))

            molecule = MOLECULE(params_instance)
            field = ELECTRICFIELD(times, params_instance)

            if params_instance.chkfile_path is not None and os.path.exists(params_instance.chkfile_path):
                try:
                    _ = read_field_csv(params_instance.eField_path)
                    _ = read_field_csv(params_instance.pField_path)
                    logger.debug(f"Checkpoint file {params_instance.chkfile_path} found as well as properly formatted field files: {params_instance.eField_path} and {params_instance.pField_path}. Skipping electric/polarizability file generation.")
                except Exception as e:
                    print(f"Error reading file: {e}")
            else:
                initCSV(params_instance.eField_path, "Electric Field intensity in atomic units")
                initCSV(params_instance.pField_path, "Molecule's Polarizability Field intensity in atomic units")
                logger.debug(f"Field files successfully initialized: {params_instance.eField_path} and {params_instance.pField_path}")

            rows = ((t, i0, i1, i2) for t, (i0, i1, i2) in zip(times, field.field))
            with open(params_instance.eField_path, 'a', newline='') as csvfile:
                writer = csv.writer(csvfile)
                writer.writerows(rows)
            
            logger.debug(f"Electric field successfully added to {params_instance.eField_path}")
        
            # Select propagator
            if params_instance.propagator == "step":
                propagate = propagate_step
            elif params_instance.propagator == "magnus2":
                propagate = propagate_magnus2
            elif params_instance.propagator == "rk4":
                propagate = propagate_rk4

            for index, current_time in enumerate(field.times):
                if current_time < molecule.chkpoint_time:
                    continue
                mu_arr = propagation(params_instance, molecule, field.field[index], propagate)
                logging.info(f"At {current_time} au, combined Bohr output is {mu_arr} in au")
                updateCSV(params_instance.pField_path, current_time, *mu_arr)
                if params_instance.chkfile_path and index % params_instance.chkfile_freq == 0:
                    update_chkfile(params_instance, molecule, current_time)

            show_eField_pField(params_instance.eField_path, params_instance.pField_path)

        except Exception as err:
            logger.error(f"RT-TDDFT failed: {err}", exc_info=True)
            sys.exit(1)

    if params.transform:
        # Define directions and storage for threads and pField paths
        directions = ['x', 'y', 'z']
        threads = []
        pField_paths = []

        # Set up and start a thread for each direction
        for dir in directions:
            dir_path = f"{dir}_dir"
            os.makedirs(dir_path, exist_ok=True)

            # Create a deep copy of params to ensure thread safety
            params_copy = copy.deepcopy(params)
            params_copy.dir = dir

            # Update all file paths to use the direction-specific directory
            for attr in ['eField_path', 'pField_path', 'pField_Transform_path', 'chkfile_path', 'eField_vs_pField_path', 'eV_spectrum_path']:
                if hasattr(params_copy, attr):
                    original_path = getattr(params_copy, attr)
                    file_name = os.path.basename(original_path)
                    new_path = os.path.join(dir_path, file_name)
                    setattr(params_copy, attr, new_path)

            # Store the pField path for later use in transform
            pField_paths.append(params_copy.pField_path)

            # Create and start a thread for this direction
            thread = threading.Thread(target=run_computation, args=(params_copy,))
            threads.append(thread)
            thread.start()

        # Wait for all threads to complete
        for thread in threads:
            thread.join()

        # Apply Fourier transform to the pField CSV files
        transform(pField_paths[0], pField_paths[1], pField_paths[2], params.pField_Transform_path, params.eV_spectrum_path)
    else:
        # Run the original single-threaded computation
        run_computation(params)

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/input/__init__.py
# input/__init__.py
from .parser import inputFilePrepare
from .params import PARAMS
from .cli import parse_arguments

__all__ = ['inputFilePrepare', 'PARAMS', 'parse_arguments']

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/input/cli.py
# input/cli.py
import argparse

def parse_arguments():
    """
    Parse command-line arguments for the RT-TDDFT simulation.

    This function sets up an argument parser with options for simulation parameters,
    file paths, and verbosity levels, returning the parsed arguments.

    Parameters:
    None

    Returns:
    argparse.Namespace
        An object containing the parsed command-line arguments.
    """
    parser = argparse.ArgumentParser(
        description="Meep simulation with Bohr dipole moment calculation.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument('-f', '--input', required=True, type=str, help="Path to the PlasMol input file.")
    parser.add_argument('-l', '--log', help="Log file name.")
    parser.add_argument('-v', '--verbose', action='count', default=1, help="Increase verbosity (use up to -vv).")
    parser.add_argument('-r', '--restart', dest='restart', action='store_true', help="Before simulation starts, removes old files: eField_path, pField_path, pField_Transform_path, chkfile_path, eField_vs_pField_path, and eV_spectrum_path.")

    args = parser.parse_args()
    if args.log and args.verbose == 0:
        args.verbose = 1

    return args


// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/input/params.py
# input/params.py
import logging
import numpy as np

logger = logging.getLogger("main")

class PARAMS:
    """
    Container for simulation parameters given from input files and cli inputs.
    """
    def __init__(self, preparams):
        self.preparams = preparams
        self.type = self.preparams["simulation_type"]
        self.restart = self.preparams["args"]["restart"]
        self.buildSettingsParams()

        if self.type == 'PlasMol':
            self.buildQuantumParams()
            self.buildclassicalParams()
        elif self.type == 'Quantum':
            self.buildQuantumParams()
        elif self.type == 'Classical':
            self.buildclassicalParams()

        delattr(self, 'preparams')


    def buildQuantumParams(self):
        self.pField_path = self.preparams["quantum"]["files"]["pField_path"]
        self.pField_Transform_path = self.preparams["quantum"]["files"]["pField_Transform_path"]
        self.eField_vs_pField_path = self.preparams["quantum"]["files"]["eField_vs_pField_path"]
        self.eV_spectrum_path = self.preparams["quantum"]["files"]["eV_spectrum_path"]
        self.chkfile_path = self.preparams["quantum"]["files"]["chkfile"]["path"] if "chkfile" in self.preparams["quantum"]["files"] else None
        self.chkfile_freq = self.preparams["quantum"]["files"]["chkfile"]["frequency"] if "chkfile" in self.preparams["quantum"]["files"] else None
        self.molecule_coords = self.preparams["quantum"]["rttddft"]["geometry"]["molecule_coords"]
        self.molecule_atoms = self.preparams["quantum"]["rttddft"]["geometry"]["atoms"]
        self.atoms = self.preparams["quantum"]["rttddft"]["geometry"]["atoms"]
        self.basis = self.preparams["quantum"]["rttddft"]['basis']
        self.charge = self.preparams["quantum"]["rttddft"]['charge']
        self.spin = self.preparams["quantum"]["rttddft"]['spin']
        self.xc = self.preparams["quantum"]["rttddft"]['xc']
        self.propagator = self.preparams["quantum"]["rttddft"]["propagator"].lower()
        self.check_tolerance = self.preparams["quantum"]["rttddft"]['check_tolerance']
        self.transform = True if "transform" in self.preparams["quantum"]["rttddft"] else False

        if 'source' in self.preparams['quantum']:
            if not self.type == 'Quantum':
                logger.warning("Source block found in quantum section, but full PlasMol simulation is available. Ignoring source in quantum section. For full PlasMol simulation, please add source to classical section.")
            else:
                self.shape = self.preparams["quantum"]["source"]['shape']
                self.peak_time_au = self.preparams["quantum"]["source"]['peak_time_au']
                self.width_steps = self.preparams["quantum"]["source"]['width_steps']
                self.intensity_au = self.preparams["quantum"]["source"]['intensity_au']
                self.wavelength_nm = self.preparams["quantum"]["source"]['wavelength_nm'] if self.shape == 'pulse' else None
                self.dir = self.preparams["quantum"]["source"]['dir'] if not self.transform else None
                # if you want to add a custom shape you must add support for the relevant parameters here

        if self.propagator == 'step':
            pass
        elif self.propagator == 'magnus2':
            self.maxiter = self.preparams["quantum"]["rttddft"]["maxiter"]
            self.pc_convergence = self.preparams["quantum"]["rttddft"]["pc_convergence"]
        elif self.propagator == 'rk4':
            pass
        else:
            raise ValueError(f"Unsupported propagator: {self.propagator}. Please provide in the molecule input file one of the acceptable Density matrix propagators: step, rk4, or magnus2.")
        


    def buildclassicalParams(self):
        import meep as mp

        def getMoleculeLocation(self):
            if self.preparams['classical'].get("molecule", None) is None:
                logger.info('No molecule chosen for simulation. Continuing without it.')
                return None
            
            return self.preparams['classical']['molecule']

        def getSimulationParams(self):
            if self.preparams['classical'].get("simulation", None) is None:
                raise RuntimeError('No simulation parameters chosen for simulation. Exiting.')
            
            return self.preparams['classical']["simulation"]

        def getSource(self):
            from ..classical import sources

            if self.preparams['classical'].get("source", None) is None:
                logger.info('No source chosen for simulation. Continuing without it.')
                return None

            source_type = self.preparams['classical']['source']['sourceType']
            if source_type == 'continuous':
                source_params = {
                    key: value for key, value in self.preparams['classical']['source'].items()
                    if key in ['frequency', 'wavelength', 'start_time', 'end_time', 
                            'width', 'fwidth', 'slowness', 'is_integrated', 'component']
                }
                source = sources.ContinuousSource(
                    sourceCenter=self.preparams['classical']['source']['sourceCenter'],
                    sourceSize=self.preparams['classical']['source']['sourceSize'],
                    **source_params
                )
            elif source_type == 'gaussian':
                source_params = {
                    key: value for key, value in self.preparams['classical']['source'].items()
                    if key in ['frequency', 'wavelength', 'width', 'fwidth', 'start_time', 
                            'cutoff', 'is_integrated', 'component']
                }
                source = sources.GaussianSource(
                    sourceCenter=self.preparams['classical']['source']['sourceCenter'],
                    sourceSize=self.preparams['classical']['source']['sourceSize'],
                    **source_params
                )
            elif source_type == 'chirped':
                source_params = {
                    key: value for key, value in self.preparams['source'].items()
                    if key in ['frequency', 'wavelength', 'width', 'peakTime', 'chirpRate', 
                            'start_time', 'end_time', 'is_integrated', 'component']
                }
                source = sources.ChirpedSource(
                    sourceCenter=self.preparams['source']['sourceCenter'],
                    sourceSize=self.preparams['source']['sourceSize'],
                    **source_params
                )
            elif source_type == 'pulse':
                source_params = {
                    key: value for key, value in self.preparams['classical']['source'].items()
                    if key in ['frequency', 'wavelength', 'width', 'peakTime', 'start_time', 'end_time', 'is_integrated', 'component']
                }

                source = sources.PulseSource(
                    sourceCenter=self.preparams['classical']['source']['sourceCenter'],
                    sourceSize=self.preparams['classical']['source']['sourceSize'],
                    **source_params
                )
            # elif ....
                # ------------------------------------ #
                #          Additional custom           #
                #         classes for sources          #
                #           can be added to            #
                #        `classical/sources.py`        #
                #    and then added here for support   #
                # ------------------------------------ #
            else:
                raise ValueError(f"Unsupported source type: {source_type}")

            return source

        def getNanoparticle(self):
            if self.preparams['classical'].get("object", None) is None:
                logger.info('No object chosen for simulation. Continuing without it.')
                return None

            if self.preparams['classical']['object']['material'] == 'Au':
                from meep.materials import Au_JC_visible as Au
                material = Au
            elif self.preparams['classical']['object']['material'] == 'Ag':
                from meep.materials import Ag
                material = Ag
            else:
                raise ValueError(f"Unsupported material type: {self.preparams['classical']['object']['material']}")

            objectNP = mp.Sphere(radius=self.preparams['classical']['object']['radius'], center=self.preparams['classical']['object']['center'], material=material)
            return objectNP

        def getSymmetry(self):
            if self.preparams['classical']['simulation'].get("symmetries", None) is None:
                logger.info('No symmetries chosen for simulation. Continuing without them.')
                return None
            
            sym = self.preparams['classical']['simulation']['symmetries']
            symmetries = []
            for i in range(len(sym)):
                if sym[i] in ['X', 'Y', 'Z']:
                    if i + 1 < len(sym):
                        try:
                            phase = int(sym[i + 1])
                        except ValueError:
                            raise ValueError(
                                f"Symmetry '{sym[i]}' is not followed by a valid integer.")

                        if sym[i] == 'X':
                            symmetries.append(mp.Mirror(mp.X, phase=phase))
                        elif sym[i] == 'Y':
                            symmetries.append(mp.Mirror(mp.Y, phase=phase))
                        elif sym[i] == 'Z':
                            symmetries.append(mp.Mirror(mp.Z, phase=phase))
                    else:
                        raise ValueError(f"Symmetry '{sym[i]}' has no value following it.")
            if not symmetries:
                raise ValueError(f"Unsupported symmetry type: {sym}")
            else:
                return symmetries

        def gethdf5(self):
            if self.preparams['classical'].get("hdf5", None) is None:
                logger.info('No picture output chosen for simulation. Continuing without it.')
                return None

            if any(key not in self.preparams['classical']['hdf5'] for key in ['timestepsBetween', 'intensityMin', 'intensityMax']):
                raise ValueError("If you want to generate pictures, you must provide timestepsBetween, intensityMin, and intensityMax.")

            if 'imageDirName' not in self.preparams['classical']['hdf5']:
                import os 
                from datetime import datetime
                self.preparams['classical']['hdf5']['imageDirName'] = f"classical-{datetime.now().strftime('%m%d%Y_%H%M%S')}"
                logger.info(f"Directory for images: {os.path.abspath(self.preparams['classical']['hdf5']['imageDirName'])}")

            return self.preparams['classical']['hdf5']
        
        self.simulation_params = getSimulationParams(self)
        self.molecule_position = getMoleculeLocation(self)
        self.source = getSource(self)
        self.symmetry = getSymmetry(self)
        self.nanoparticle = getNanoparticle(self)
        self.hdf5 = gethdf5(self)

        from .. import constants
        if 'resolution' in self.simulation_params:
            dtAlt = (0.5 / self.simulation_params["resolution"]) * constants.convertTimeMeep2Atomic
            if not np.isclose(dtAlt, self.dt):
                logger.info(f"Resolution given in simulation parameters does not generate given time step 'dt'. Ignoring given resolution, using new resolution: {newResolution}")
                newResolution = round(0.5 / (self.dt / constants.convertTimeMeep2Atomic))
                self.simulation_params["resolution"] = newResolution
        else:
            newResolution = round(0.5 / (self.dt / constants.convertTimeMeep2Atomic))
            self.simulation_params["resolution"] = newResolution


    def buildSettingsParams(self):
        self.dt = self.preparams["settings"]["dt"]
        self.t_end = self.preparams["settings"]["t_end"]
        self.eField_path = self.preparams["settings"]["eField_path"]



// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/input/parser.py
# input/parser.py
import re
import logging
import numpy as np

logger = logging.getLogger("main")

def inputFilePrepare(args):
    input = args.input
    classical, quantum, settings = parseSections(input)
    settings_params = parseclassicalSection(settings)
    classical_params = parseclassicalSection(classical) if classical is not None else None
    quantum_params = parseQuantumSection(quantum) if quantum is not None else None

    if not 'dt' in settings_params:
        raise RuntimeError("No 'dt' value given in settings file. This value is required.")
    if not 't_end' in settings_params:
        raise RuntimeError("No 't_end' value given in settings file. This value is required.")

    if classical_params is not None and quantum_params is not None:
        simulation_type = 'PlasMol'
        if not 'simulation' in classical_params:
            raise RuntimeError("No 'simulation' block found in classical block. Please specify the 'simulation' parameters in the classical block.")
        if not 'molecule' in classical_params:
            raise RuntimeError("No 'molecule' block found in classical block, but Quantum block found. Please specify the 'molecule' parameters in the classical block.")
    elif quantum_params is not None:
        simulation_type = 'Quantum'
        logger.info("Only RT-TDDFT input file given. Running RT-TDDFT simulation only.")
    elif classical_params is not None:
        if not 'simulation' in classical_params:
            raise RuntimeError("No 'simulation' block found in classical block. Please specify the 'simulation' parameters in the classical block.")
        simulation_type = 'Classical'
        logger.info("Only classical input file given. Running classical simulation only.")
    else:
        raise RuntimeError("The minimum required parameters were not given. Please check guidelines for information on minimal requirements.")
    
    preparams = {}
    preparams["settings"] = settings_params
    if classical_params is not None:
        preparams["classical"] = classical_params 
    if quantum_params is not None:
        preparams["quantum"] = quantum_params

    args = vars(args)
    args = {k: v for k, v in args.items() if v is not None}
    preparams["args"] = args
    
    preparams["simulation_type"] = simulation_type
    return preparams


def parseSections(input_file):
    comment_pattern = re.compile(r"(#|--|%)(.*)$")

    in_classical_section = False
    in_quantum_section = False
    in_settings_section = False
    classical_section = None
    quantum_section = None
    settings_section = ""

    with open(input_file) as f:
        for raw_line in f:
            line = comment_pattern.sub('', raw_line).strip()
            if not line:
                continue

            parts = line.split()

            if parts[0] == 'start' and parts[1] == 'classical' and len(parts) == 2:
                in_classical_section = True
                classical_section = ""
                continue
            elif parts[0] == 'end' and parts[1] == 'classical' and len(parts) == 2:
                in_classical_section = False
                continue
            elif parts[0] == 'start' and parts[1] == 'quantum' and len(parts) == 2:
                in_quantum_section = True
                quantum_section = ""
                continue
            elif parts[0] == 'end' and parts[1] == 'quantum' and len(parts) == 2:
                in_quantum_section = False
                continue
            elif parts[0] == 'start' and (parts[1] == 'settings' or parts[1] == 'general') and len(parts) == 2:
                in_settings_section = True
                settings_section = ""
                continue
            elif parts[0] == 'end' and (parts[1] == 'settings' or parts[1] == 'general') and len(parts) == 2:
                in_settings_section = False
                continue

            if in_classical_section:
                classical_section += line + "\n"
            elif in_quantum_section:
                quantum_section += line + "\n"
            elif in_settings_section:
                settings_section += line + "\n"
            else:
                settings_section += line + "\n"

    return classical_section, quantum_section, settings_section


def evaluate_expression(expression):
    """Safely evaluate simple math expressions."""
    try:
        return eval(expression, {"__builtins__": None}, {})
    except:
        return expression


def parse_value_token(tok):
    """Bool, numeric, or leave string."""
    t = tok.lower()
    if t == 'true':  return True
    if t == 'false': return False
    try:
        val = evaluate_expression(tok)
        return float(val) if isinstance(val, (int, float)) else val
    except:
        return tok


def parse_value_token(token):
    """Attempt to parse a value as int, float, or leave as string."""
    try:
        return int(token)
    except ValueError:
        try:
            return float(token)
        except ValueError:
            if token.lower() == "true":
                return True
            elif token.lower() == "false":
                return False
            return token


def parseclassicalSection(input):
    comment_pattern = re.compile(r"(#|--|%)(.*)$")
    params = {}
    stack = []  # Stack of tuples: (section_name, section_dict)

    for raw_line in input.splitlines():
        # Remove comments and whitespace
        line = comment_pattern.sub('', raw_line).strip()
        if not line:
            continue

        parts = line.split()
        kw = parts[0]

        if kw == 'start' and len(parts) == 2:
            name = parts[1]
            new_section = {}
            if stack:
                # Add the new nested section to the current parent section
                parent = stack[-1][1]
                if name in parent:
                    raise ValueError(f"Duplicate section '{name}' inside '{stack[-1][0]}'")
                parent[name] = new_section
            else:
                if name in params:
                    raise ValueError(f"Duplicate top-level section '{name}'")
                params[name] = new_section
            stack.append((name, new_section))

        elif kw == 'end' and len(parts) == 2:
            end_name = parts[1]
            if not stack:
                raise ValueError(f"Unmatched end {end_name}")
            open_name, _ = stack.pop()
            if open_name != end_name:
                raise ValueError(f"Mismatched end: expected end {open_name}, got end {end_name}")

        else:
            # Normal key-value pair, goes into the current section dict
            current = stack[-1][1] if stack else params
            key, *vals = parts
            if not vals:
                current[key] = None  # Support for keys without values
            elif len(vals) == 1:
                current[key] = parse_value_token(vals[0])
            else:
                current[key] = [parse_value_token(v) for v in vals]

    if stack:
        open_secs = ", ".join(n for n, _ in stack)
        raise ValueError(f"Unclosed section(s): {open_secs}")

    return params


def parseQuantumSection(input):
    def prepareCoordinates(atoms, coords):
        molecule_coords = ""
        for index, atom in enumerate(atoms):
            molecule_coords += " " + atom
            molecule_coords += " " + str(coords[atom+str(index+1)][0])
            molecule_coords += " " + str(coords[atom+str(index+1)][1])
            molecule_coords += " " + str(coords[atom+str(index+1)][2])
            if index != (len(atoms)-1):
                molecule_coords += ";"
        return molecule_coords

    def convert_to_bohr(coords, units):
        if units.lower().startswith("angstrom"):
            factor = 1.8897259886
        elif units.lower().startswith("bohr"):
            factor = 1.0
        else:
            raise ValueError(f"Unknown units '{units}', must be 'angstrom' or 'bohr'")
        return { label: xyz * factor for label, xyz in coords.items() }

    comment_pattern = re.compile(r"(#|--|%)(.*)$")
    params = {}
    stack = []  # Stack of tuples: (section_name, section_dict)
    geometry = {'atoms': [], 'coords': {}}
    raw_coords = {}
    atom_counts = 0
    in_mol = False

    for raw_line in input.splitlines():
        # Remove comments and whitespace
        line = comment_pattern.sub('', raw_line).strip()
        if not line:
            continue

        if line.lower().startswith('start geometry'):
            in_mol = True
            continue
        if line.lower().startswith('end geometry'):
            in_mol = False
            continue
        if in_mol:
            parts = line.split()
            atom = parts[0]
            coords = list(map(float, parts[1:4]))
            atom_counts += 1
            label = f"{atom}{atom_counts}"
            geometry['atoms'].append(atom)
            raw_coords[label] = np.array(coords)
            continue

        parts = line.split()
        kw = parts[0]

        if kw == 'start' and len(parts) == 2:
            name = parts[1]
            new_section = {}
            if stack:
                # Add the new nested section to the current parent section
                parent = stack[-1][1]
                if name in parent:
                    raise ValueError(f"Duplicate section '{name}' inside '{stack[-1][0]}'")
                parent[name] = new_section
            else:
                if name in params:
                    raise ValueError(f"Duplicate top-level section '{name}'")
                params[name] = new_section
            stack.append((name, new_section))

        elif kw == 'end' and len(parts) == 2:
            end_name = parts[1]
            if not stack:
                raise ValueError(f"Unmatched end {end_name}")
            open_name, _ = stack.pop()
            if open_name != end_name:
                raise ValueError(f"Mismatched end: expected end {open_name}, got end {end_name}")

        else:
            # Normal key-value pair, goes into the current section dict
            current = stack[-1][1] if stack else params
            key, *vals = parts
            if not vals:
                current[key] = None  # Support for keys without values
            elif len(vals) == 1:
                current[key] = parse_value_token(vals[0])
            else:
                current[key] = [parse_value_token(v) for v in vals]

    if stack:
        open_secs = ", ".join(n for n, _ in stack)
        raise ValueError(f"Unclosed section(s): {open_secs}")

    geometry['coords'] = convert_to_bohr(raw_coords, params["rttddft"]["units"])
    params["rttddft"]['geometry'] = geometry
    params["rttddft"]['geometry']['molecule_coords'] = prepareCoordinates(params["rttddft"]['geometry']['atoms'], params["rttddft"]['geometry']['coords'])
    
    return params

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/main.py
# main.py
import os
import sys

# Dynamically set up package context for direct execution (python main.py)
if __name__ == "__main__" and __package__ is None:
    current_dir = os.path.dirname(os.path.abspath(__file__))
    parent_dir = os.path.dirname(current_dir)
    sys.path.insert(0, parent_dir)
    __package__ = os.path.basename(current_dir)  # Sets __package__ to "src" (or whatever your directory is named)

import logging
import numpy as np

from . import constants

from .drivers import *
from .input.params import PARAMS
from .utils.logging import PRINTLOGGER

from .input.cli import parse_arguments
from .input.parser import inputFilePrepare

# main.py
if __name__ == "__main__":
    try:
        # Set up logging
        log_format = '%(levelname)s: %(message)s'
        logger = logging.getLogger()
        if logger.hasHandlers():
            logger.handlers.clear()

        # Step 1: Grab CLI args
        args = parse_arguments()

        if args.verbose >= 2:
            logger.setLevel(logging.DEBUG)
        elif args.verbose == 1:
            logger.setLevel(logging.INFO)
        else:
            logger.setLevel(logging.WARNING)

        # Use FileHandler if a log file is specified; otherwise, use StreamHandler.
        if args.log:
            handler = logging.FileHandler(args.log, mode='w')
        else:
            handler = logging.StreamHandler(sys.stdout)
        handler.setFormatter(logging.Formatter(log_format))
        logger.addHandler(handler)

        logger.propagate = False
    
        sys.stdout = PRINTLOGGER(logger, logging.INFO)
        logging.getLogger("h5py").setLevel(logging.INFO)
        logging.getLogger("matplotlib").setLevel(logging.INFO)
        logging.getLogger("PIL").setLevel(logging.INFO)

        # Step 2: Identify parsing workflow from CLI args
        preparams = inputFilePrepare(args)
        logger.debug(f"Arguments given and pre-parsed successfully: {preparams}")

        # Step 3: Merge all found parameters
        logger.debug("Merging parameters from input file(s) with the CLI inputs. CLI takes priority for duplicate values.")
        params = PARAMS(preparams)
        
        logger.debug(f"Arguments given and parsed successfully: ")
        for key, value in vars(params).items():
            logger.debug(f"\t\t{key}: {value}")

        if params.restart:
            for attr in ['eField_path', 'pField_path', 'pField_Transform_path', 'chkfile_path', 'eField_vs_pField_path', 'eV_spectrum_path']:
                if hasattr(params, attr):
                    file_path = getattr(params, attr)
                    if file_path is not None and os.path.isfile(file_path):
                        try:
                            os.remove(file_path)
                            logger.info(f"Deleted {file_path}")
                        except OSError as e:
                            logger.error(f"Error deleting {file_path}: {e}")
                    else:
                        logger.debug(f"No such file: {file_path}")

        time_values = np.arange(0, params.t_end + params.dt, params.dt)
        interpolated_times = np.linspace(0, time_values[-1], len(time_values))
        logger.info(f"The timestep for this simulation is {params.dt} in au or {params.dt / constants.T_AU_FS} in fs.")
        logger.info(f"The simulation will propagate until {params.t_end} in au or {params.t_end / constants.T_AU_FS} in fs.")
        logger.debug(f"There will be {len(interpolated_times)} timesteps until the simulation finishes.")

        # Step 4: Execute proper workflow
        if params.type == 'PlasMol':
            run_plasmol(params)
        elif params.type == 'Quantum':
            run_quantum(params)
        elif params.type == 'Classical':
            run_classical(params)

    except Exception as err:
        logger.error(f"Simulation failed: {err}", exc_info=True)
        sys.exit(1)

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/quantum/__init__.py
# quantum/__init__.py
from .molecule import MOLECULE
from .electric_field import ELECTRICFIELD
from .propagation import propagation
from .chkfile import update_chkfile, restart_from_chkfile

__all__ = ['MOLECULE', 'ELECTRICFIELD', 'propagation', 'update_chkfile', 'restart_from_chkfile']

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/quantum/chkfile.py
# quantum/chkfile.py
import numpy as np
import logging
import _pickle

logger = logging.getLogger("main")

def update_chkfile(params, molecule, chkpoint_time):
    """
    Save a checkpoint file containing the current state of the simulation.

    This function creates a .npz file with simulation data including the current time,
    initial density matrix, molecular orbital coefficients, Fock matrix in orthogonal basis,
    and an additional array based on the propagator method ('step' or 'magnus2').
    The file is saved with the name specified in molecule.chkfile_path, appending .npz if not present.

    Parameters:
    molecule : object
        The molecule object containing simulation data.
    chkpoint_time : float
        The current time in the simulation in atomic units.

    Returns:
    None
    """
    # ensure .npz extension
    if not params.chkfile_path.endswith(".npz"):
        params.chkfile_path = params.chkfile_path + ".npz"
    fn = params.chkfile_path

    method = params.propagator.lower()
    save_dict = {
        "chkpoint_time":  chkpoint_time,
        "D_ao_0":         molecule.D_ao_0,
        "mo_coeff":       molecule.mf.mo_coeff,
    }

    if method == "step":
        save_dict["C_orth_ndt"] = molecule.C_orth_ndt
    elif method == "magnus2":
        save_dict["F_orth_n12dt"] = molecule.F_orth_n12dt

    try:
        np.savez(fn, **save_dict)
    except IOError as e:
        logger.error(f"Failed to write checkpoint file {fn}: {e}")
        raise

    logger.debug(f"Wrote checkpoint to {fn} with keys: {list(save_dict)}")


def restart_from_chkfile(molecule, params):
    """
    Load the simulation state from a checkpoint file.

    This function loads data from a .npz checkpoint file specified in molecule.chkfile_path,
    updating the molecule object with the saved state. It includes common data and
    propagator-specific arrays based on the method ('step' or 'magnus2').

    Parameters:
    molecule : object
        The molecule object to be updated with checkpoint data.

    Returns:
    None
    """
    fn = params.chkfile_path

    try:
        data = np.load(fn, allow_pickle=True)
    except FileNotFoundError:
        logger.error(f"Checkpoint file {fn} not found.")
        raise
    except KeyError as e:
        logger.error(f"Missing key in checkpoint file {fn}: {e}")
        raise
    except (_pickle.UnpicklingError, ValueError):
        logger.error(f"{fn} is not a valid checkpoint archive.")
        raise
    
    logger.debug(f"Loading checkpoint from {fn}")

    # common data
    molecule.chkpoint_time = float(data["chkpoint_time"])
    molecule.D_ao_0       = data["D_ao_0"]
    molecule.mf.mo_coeff = data["mo_coeff"]

    # conditional
    method = params.propagator.lower()
    if method == "step" and "C_orth_ndt" in data:
        molecule.C_orth_ndt = data["C_orth_ndt"]
    elif method == "magnus2" and "F_orth_n12dt" in data:
        molecule.F_orth_n12dt = data["F_orth_n12dt"]

    logger.debug(
        f"Restarted at t={molecule.chkpoint_time} au; "
        f"loaded propagator='{method}', "
        f"arrays: {list(data.keys())}"
    )

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/quantum/electric_field.py
# quantum/electric_field.py
import logging 
import numpy as np

from .. import constants

logger = logging.getLogger("main")

class ELECTRICFIELD:
    def __init__(self, times, params):
        self.shape = params.shape
        self.intensity_au = params.intensity_au
        self.peak_time_au = params.peak_time_au
        self.width_au = params.width_steps * params.dt
        self.times = times
        self.dir = params.dir

        if self.shape == 'pulse':
            self.wavelength_nm = params.wavelength_nm
            self.wavelength_au = self.wavelength_nm * constants.D_AU_NM
        elif self.shape == 'kick':
            pass
        # elif self.shape == 'custom_shape'...
        #   if additional parameters need to be added for your custom shape
        #   you must add support for them in the input/params.py method: buildQuantumParams()
        else:
            raise ValueError("Invalid shape. Must be 'pulse' or 'kick'.")
        
        self.field = self.build_field()

    def build_field(self):
        """
        Compute the electric field for a given array of times.

        Generates the field based on the shape: 'pulse' (oscillatory) or 'kick' (Gaussian),
        applying it along the specified direction with optional smoothing.

        Parameters:
        times : np.ndarray
            Array of times in atomic units.
        dir : str
            Direction of the field ('x', 'y', or 'z').

        Returns:
        np.ndarray
            Array of shape (len(times), 3) with field components [x, y, z].
        """

        t = np.asarray(self.times) # must be in au
        if self.shape == 'pulse':
            omega = 2 * np.pi * constants.C_AU / self.wavelength_au
            carrier  = np.exp(1j * omega * (t - self.peak_time_au))
            envelope = np.exp(-((t - self.peak_time_au)**2) / (2 * self.width_au**2))
            active_component = self.intensity_au * np.real(carrier * envelope)
        elif self.shape == 'kick':
            envelope = np.exp(-((t - self.peak_time_au)**2) / (2 * self.width_au**2))
            active_component = self.intensity_au * envelope
        # ------------------------------------ #
        #              Additional              #
        #    custom sources can be defined     #
        #      here and supported above        #
        #             as commented             #
        # ------------------------------------ #


        field = np.zeros((len(t), 3))
        dir = self.dir.lower()
        if dir == 'x':
            field[:, 0] = active_component
        elif dir == 'y':
            field[:, 1] = active_component
        elif dir == 'z':
            field[:, 2] = active_component
        else:
            raise ValueError("Invalid direction. Must be 'x', 'y', or 'z'.")
        return field



// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/quantum/molecule.py
# quantum/molecule.py
import os
import sys
import math
import logging
import numpy as np
from pyscf import gto, dft
from pyscf.scf import addons

from .. import constants
from ..quantum.chkfile import restart_from_chkfile

logger = logging.getLogger("main")

class MOLECULE():
    """
    Represents a molecule in the RT-TDDFT simulation.

    Manages quantum mechanical properties, SCF calculations, and time propagation state.
    """
    def __init__(self, params):
        """
        Initialize the MOLECULE object with input file and parameters.

        Sets up the molecule from the input file, performs initial SCF calculation,
        and loads from checkpoint if available.

        Parameters:
        params : object
            Parameters object with simulation settings.

        Returns:
        None
        """
        # Format molecule string as required by PySCF
        mol = gto.M(atom=params.molecule_coords,
                    basis=params.basis,
                    unit='B',
                    charge=int(params.charge),
                    spin=int(params.spin))
        self.mf = dft.RKS(mol)
        self.mf.xc = params.xc
        self.mf.kernel()
        
        charges = self.mf.mol.atom_charges()
        coords = self.mf.mol.atom_coords()
        nuc_charge_center = np.einsum('z,zx->x', charges, coords) / charges.sum()
        self.mf.mol.set_common_orig_(nuc_charge_center)

        self.charges_over_time = []
        self.homo_lumo_jump_over_time = []
        self.homo_index = np.where(self.mf.mo_occ > 0)[0][-1]  # Last occupied orbital
        self.lumo_index = np.where(self.mf.mo_occ == 0)[0][0]  # First virtual orbital

        # Initialize matrices and wavefunction
        self.S = self.mf.get_ovlp()
        self.X = addons.canonical_orth_(self.S)

        if not self.is_hermitian(np.dot(self.X.conj().T, self.X), tol=params.check_tolerance):
            logger.warning("Orthogonalization matrix X may not be unitary")
            
        self.occ = self.mf.get_occ()
        self.D_ao_0 = self.mf.make_rdm1(mo_occ=self.occ)

        if len(np.shape(self.D_ao_0)) == 3:
            self.nmat = 2
            sys.exit("nmat == 2")
        else:
            self.nmat = 1

        self.chkpoint_time = 0
        
        if params.chkfile_path is not None and os.path.exists(params.chkfile_path):
            restart_from_chkfile(self, params)
            self.D_ao = self.mf.make_rdm1(mo_occ=self.occ)
            self.F_orth = self.get_F_orth(self.D_ao) # Should this include exc? at what time?
        else: 
            self.D_ao = self.D_ao_0
            self.F_orth = self.get_F_orth(self.D_ao)
            self.F_orth_n12dt = self.F_orth

        if not self.is_hermitian(self.D_ao, tol=1e-12):
            raise ValueError("Initial density matrix in AO is not Hermitian")
        
        self.volume = self.get_volume(params.molecule_atoms)

    def get_F_orth(self, D_ao, exc=None):
        """
        Compute the Fock matrix in the orthogonal basis.

        Includes the effect of an external field if provided.

        Parameters:
        D_ao : np.ndarray
            Density matrix in atomic orbital basis.
        exc : np.ndarray, optional
            External electric field components [x, y, z].

        Returns:
        np.ndarray
            Fock matrix in orthogonal basis.
        """
        F_ao = self.mf.get_fock(dm=D_ao).astype(np.complex128)
        if exc is not None:
            F_ao += self.calculate_potential(exc)
        return np.matmul(self.X.conj().T, np.matmul(F_ao, self.X))

    def rotate_coeff_to_orth(self, coeff_ao):
        """
        Transform molecular orbital coefficients to the orthogonal basis.

        Parameters:
        coeff_ao : np.ndarray
            Coefficients in atomic orbital basis.

        Returns:
        np.ndarray
            Coefficients in orthogonal basis.
        """
        return np.matmul(np.linalg.inv(self.X), coeff_ao)

    def rotate_coeff_away_from_orth(self, coeff_orth):
        """
        Transform molecular orbital coefficients from orthogonal to atomic orbital basis.

        Parameters:
        coeff_orth : np.ndarray
            Coefficients in orthogonal basis.

        Returns:
        np.ndarray
            Coefficients in atomic orbital basis.
        """
        return np.matmul(self.X, coeff_orth)
    
    def is_hermitian(self, A, tol):
        """
        Check if a matrix is Hermitian within a tolerance.

        Parameters:
        A : np.ndarray
            Matrix to check.
        tol : float
            Numerical tolerance for Hermitian property.

        Returns:
        bool
            True if the matrix is Hermitian within tolerance, False otherwise.
        """
        return np.allclose(A, A.conj().T, rtol=0, atol=tol)

    def get_volume(self, coords):
        volume = 0
        for atom in coords:
            element = atom[0]
            if element in constants.vdw_radii:
                radius = constants.vdw_radii[element]
                volume += (4 / 3) * math.pi * (radius ** 3)
            else:
                print(f"Warning: No van der Waals radius for {element}")
            
        # Dividing by 0.14818471 Å³ will set the volume to atomic units.
        return volume / constants.V_AU_AA3
    
    # ------------------------------------ #
    #              Additional              #
    #      measurables can be defined      #
    #    here and added mid-simulation     #
    #      in quantum/propagation.py       #
    # ------------------------------------ #

    def calculate_mu(self):
        """
        Calculate the dipole moment integrals for the molecule.

        Sets the origin to the nuclear charge center and computes dipole integrals.

        Parameters:
        None

        Returns:
        np.ndarray
            Dipole moment integrals with shape (3, nao, nao) for x, y, z components.
        """
        mu = -1 * self.mf.mol.intor('int1e_r', comp=3)
        return mu
    
    def calculate_potential(self, exc):
        """
        Calculate the potential contribution from an external electric field.

        Uses dipole moment integrals to compute the field-induced potential.

        Parameters:
        exc : np.ndarray
            External electric field components [x, y, z] in atomic units.

        Returns:
        np.ndarray
            Potential matrix in atomic orbital basis.
        """
        mu = self.calculate_mu()
        return -1 * np.einsum('xij,x->ij', mu, exc)

    # define more contractions with the density matrix below...

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/quantum/propagation.py
# quantum/propagation.py
import logging 
import numpy as np 

logger = logging.getLogger("main")

def propagation(params, molecule, field, propagate):
    """
    Perform time propagation of the molecular state.

    Propagates the molecule over time using the specified method, recording polarization
    and saving checkpoints as configured.

    Parameters:
    params : object
        Parameters object with simulation settings.
    molecule : object
        Molecule object with current state.
    field : object
        Electric field object with time-dependent field data.

    Returns:
    None
    """
    mu_arr = np.zeros(3)
    propagate(params, molecule, field)
    mu = molecule.calculate_mu()
    for i in [0, 1, 2]:
        mu_arr[i] = float((np.trace(mu[i] @ molecule.D_ao) - np.trace(mu[i] @ molecule.D_ao_0)).real)

    # ------------------------------------ #
    #              Additional              #
    #      custom tracking functions       #
    #           can be added here          #
    #  similar to molecule.calculate_mu()  #
    # ------------------------------------ #

    return mu_arr


// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/quantum/propagators/__init__.py
# quantum/propagators/__init__.py
from .step import propagate as propagate_step
from .magnus2 import propagate as propagate_magnus2
from .rk4 import propagate as propagate_rk4

__all__ = ['propagate_step', 'propagate_magnus2', 'propagate_rk4']

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/quantum/propagators/magnus2.py
# quantum/propagators/magnus2.py
import logging
import numpy as np
from scipy.linalg import expm

logger = logging.getLogger("main")

def propagate(params, molecule, exc):
    """
    Propagate molecular orbitals using the Magnus2 method.

    Implements a predictor-corrector scheme to propagate the density matrix over one time step,
    using extrapolation and iterative refinement until convergence.

    Parameters:
    params : object
        Parameters object with dt, maxiter, and pcconv attributes.
    molecule : object
        Molecule object with current state data.
    exc : np.ndarray
        External electric field at the current time step.

    Returns:
    None
    """
    C_orth = molecule.rotate_coeff_to_orth(molecule.mf.mo_coeff)
    F_orth_p12dt = 2 * molecule.F_orth - molecule.F_orth_n12dt
    C_ao_pdt_old = None

    iteration = 0
    while True:
        iteration += 1
        if iteration > params.maxiter:
            raise RuntimeError(f"Failed to converge within {params.maxiter} iterations")

        # 1) predictor
        U = expm(-1j * params.dt * F_orth_p12dt)
        C_orth_pdt = np.matmul(U, C_orth)
        C_pdt = molecule.rotate_coeff_away_from_orth(C_orth_pdt)
        
        # 2) compute new Fock
        D_ao_pdt = molecule.mf.make_rdm1(mo_coeff=C_pdt, mo_occ=molecule.occ)
        F_orth_pdt = molecule.get_F_orth(D_ao_pdt, exc)
        
        # 3) only check convergence if we have a previous value
        if C_ao_pdt_old is not None and np.linalg.norm(C_pdt - C_ao_pdt_old) < params.pc_convergence:
            molecule.mf.mo_coeff = C_pdt
            molecule.D_ao = D_ao_pdt
            molecule.F_orth = F_orth_pdt
            molecule.F_orth_n12dt = F_orth_p12dt
            logger.debug(f'Magnus2 converged in {iteration} iterations.')
            break

        # 4) update history for next iteration
        F_orth_p12dt = 0.5 * (molecule.F_orth + F_orth_pdt)
        C_ao_pdt_old = C_pdt
        molecule.mf.mo_coeff = C_pdt
        molecule.D_ao = D_ao_pdt


// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/quantum/propagators/rk4.py
# quantum/propagators/rk4.py
import logging
import numpy as np
from scipy.linalg import expm

logger = logging.getLogger("main")

def propagate(params, molecule, exc):
    """
    Propagate molecular orbitals using the Runge-Kutta 4 method.

    Parameters:
    params : object
        Parameters object with dt attribute.
    molecule : object
        Molecule object with current state data.
    exc : np.ndarray
        External electric field at the current time step.

    Returns:
    None
    """
    C_orth = molecule.rotate_coeff_to_orth(molecule.mf.mo_coeff)
    F_orth = molecule.F_orth

    # k1
    k1 = -1j * params.dt * (np.matmul(F_orth, C_orth))
    C_orth_1 = C_orth + 1/2 * k1

    # k2
    k2 = -1j * params.dt * (np.matmul(F_orth, C_orth_1))
    C_orth_2 = C_orth + 1/2 * k2

    # k3
    k3 = -1j * params.dt * (np.matmul(F_orth, C_orth_2))
    C_orth_3 = C_orth + k3

    # k4
    k4 = -1j * params.dt * (np.matmul(F_orth, C_orth_3))

    C_orth_pdt = C_orth + (k1/6 + k2/3 + k3/3 + k4/6)
    C_pdt = molecule.rotate_coeff_away_from_orth(C_orth_pdt)
    D_ao_pdt = molecule.mf.make_rdm1(mo_coeff=C_pdt, mo_occ=molecule.occ)
    F_orth_pdt = molecule.get_F_orth(D_ao_pdt, exc)

    molecule.mf.mo_coeff = C_pdt
    molecule.D_ao = D_ao_pdt
    molecule.F_orth = F_orth_pdt


// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/quantum/propagators/step.py
# quantum/propagators/step.py
import logging
import numpy as np
from scipy.linalg import expm

logger = logging.getLogger("main")

def propagate(params, molecule, exc):
    """
    Propagate molecular orbitals using the step method.
    This method is also known as the modified midpoint unitary transformation (MMUT)
    scheme from https://doi.org/10.1039/B415849K
    
    C'(t+dt) = U(t)C'(t-dt)
    U(t) = exp(-i*2dt*F')

    Parameters:
    params : object
        Parameters object with dt attribute.
    molecule : object
        Molecule object with current state data.
    exc : np.ndarray
        External electric field at the current time step.

    Returns:
    None
    """
    if hasattr(molecule, 'C_orth_ndt'):
        C_orth_ndt = molecule.C_orth_ndt
    else:
        C_orth_ndt = molecule.rotate_coeff_to_orth(molecule.mf.mo_coeff)

    F_orth = molecule.F_orth

    U = expm(-1j * 2 * params.dt * F_orth)
    
    C_orth_pdt = np.matmul(U, C_orth_ndt)
    C_pdt = molecule.rotate_coeff_away_from_orth(C_orth_pdt)
    D_ao_pdt = molecule.mf.make_rdm1(mo_coeff=C_pdt, mo_occ=molecule.occ)
    F_orth_pdt = molecule.get_F_orth(D_ao_pdt, exc)
    
    molecule.mf.mo_coeff = C_pdt
    molecule.C_orth_ndt = molecule.rotate_coeff_to_orth(molecule.mf.mo_coeff)
    molecule.D_ao = D_ao_pdt
    molecule.F_orth = F_orth_pdt


// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/utils/__init__.py
# utils/__init__.py
from .csv import initCSV, updateCSV, read_field_csv
from .logging import PRINTLOGGER
from .plotting import show_eField_pField
from .fourier import transform 
from .gif import make_gif, clear_directory

__all__ = [
    'initCSV', 'updateCSV', 'read_field_csv',
    'PRINTLOGGER',
    'show_eField_pField',
    'transform',
    'make_gif', 
    'clear_directory'
    ]

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/utils/csv.py
# utils/csv.py
import os
import csv

def initCSV(filename, comment):
    """
    Initialize a CSV file with a header and comment lines.

    Creates a new CSV file with comment lines prefixed by '#', followed by a header row:
    ['Timestamps (au)', 'X Values', 'Y Values', 'Z Values'].

    Parameters:
    filename : str
        Path to the CSV file to be created.
    comment : str
        Comment string to include at the beginning of the file, split into lines.

    Returns:
    None
    """
    with open(filename, 'w', newline='') as file:
        for line in comment.splitlines():
            file.write(f"# {line}\n")
        file.write("\n")
        writer = csv.writer(file)
        header = ['Timestamps (au)', 'X Values', 'Y Values', 'Z Values']
        writer.writerow(header)

def updateCSV(filename, timestamp, x_value=None, y_value=None, z_value=None):
    """
    Append a row of data to an existing CSV file.

    Adds a row with the timestamp and x, y, z values, defaulting to 0 if any value is not provided.
    Raises an error if the file does not exist (i.e., not initialized with initCSV).

    Parameters:
    filename : str
        Path to the CSV file.
    timestamp : float
        The timestamp for the data point in atomic units.
    x_value : float, optional
        Value for the x component, defaults to 0 if None.
    y_value : float, optional
        Value for the y component, defaults to 0 if None.
    z_value : float, optional
        Value for the z component, defaults to 0 if None.

    Returns:
    None
    """
    file_exists = os.path.exists(filename)
    row = [timestamp, x_value if x_value is not None else 0,
           y_value if y_value is not None else 0,
           z_value if z_value is not None else 0]
    
    if not file_exists:
        raise RuntimeError(f"{filename} hasn't been initialized yet. Call 'initCSV' before calling 'updateCSV'.")
    
    with open(filename, 'a', newline='') as file:
        writer = csv.writer(file)
        writer.writerow(row)

def read_field_csv(file_path):
    """
    Read field values from a CSV file.

    Parses a CSV file with a header starting with 'Timestamps', returning four lists
    for time values and field components (x, y, z).

    Parameters:
    file_path : str
        Path to the CSV file.

    Returns:
    tuple
        A tuple of four lists: (time_values, x, y, z),
        each containing float values.
    """
    time_values, x, y, z = [], [], [], []
    with open(file_path, mode='r', newline='') as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            if row and row[0].startswith("Timestamps"):
                break
        for row in reader:
            if len(row) < 4:
                continue
            time_values.append(float(row[0]))
            x.append(float(row[1]))
            y.append(float(row[2]))
            z.append(float(row[3]))
    return time_values, x, y, z

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/utils/fourier.py
# utils/fourier.py
import logging
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from .. import constants

logger = logging.getLogger("main")

init_w_eV = float(0)
final_w_eV = float(35)
step_w_eV = float(0.1)
nw = int(final_w_eV/step_w_eV)
freq_eV = np.arange(init_w_eV, final_w_eV, step_w_eV)

def fold(file_x, file_y, file_z):
    def read_dipole_component(filename, column):
        df = pd.read_csv(filename, delimiter=',', skiprows=1, header=None, names=['Timestamps (au)', 'X Values', 'Y Values', 'Z Values'], comment='#')
        df = df.dropna()
        
        # Extract columns and convert to NumPy arrays explicitly
        time = np.array(df['Timestamps (au)'].values[1:], dtype=float)
        dipole = np.array(df[column].values[1:], dtype=float)
        
        # Return as NumPy arrays
        return np.array(time), np.array(dipole)

    # Load components
    tx, dx = read_dipole_component(file_x, 'X Values')
    ty, dy = read_dipole_component(file_y, 'Y Values')
    tz, dz = read_dipole_component(file_z, 'Z Values')
    
    # Find the length of the shortest file (assuming timesteps are same)
    min_length = min(len(tx), len(ty), len(tz))

    # Trim all arrays to the shortest length
    tx = tx[:min_length]
    ty = ty[:min_length]
    tz = tz[:min_length]
    dx = dx[:min_length]
    dy = dy[:min_length]
    dz = dz[:min_length]

    # Check consistency
    if not (np.allclose(tx, ty) and np.allclose(tx, tz)):
        raise ValueError("Time points do not match across files!")

    # Build time_points and dipole_moment array
    time_points = tx
    dipole_moment = np.vstack([dx, dy, dz])  # Shape: (3, N)

    return time_points, dipole_moment


def fourier(time, dipole, file):
    dt = time[1] - time[0]

    damp = 0.010
    logger.debug("Damping factor gamma: %f",damp)

    abs_real = [[],[],[]]
    abs_imag = [[],[],[]]

    for axis in (0, 1, 2):
        logger.info(f"Starting Fourier transform of direction { {0:'x', 1:'y', 2:'z'}[axis] }")
        for step_num in range(nw):
            w = freq_eV[step_num]/27.21138 # converted to au
            S = 0j
            for k in range(len(time)):
                S += dipole[axis][k] * np.exp(-1j * w * time[k]) * np.exp(-damp * time[k]) * dt

            abs_real[axis].append(S.real)
            abs_imag[axis].append(S.imag)
            
    logger.info("Fourier transform done!")
    for i in range(3):
        abs_real[i] = np.array(abs_real[i])
        abs_imag[i] = np.array(abs_imag[i])

    np.savez(file, abs_imag)
    return abs_imag


def absorption(imag):
    fullsum = imag[0] + imag[1] + imag[2]
    return - 4 * np.pi * freq_eV / 3 / constants.C_AU * fullsum


def transform(file_x, file_y, file_z,  pField_Transform_path, eV_spectrum_path):
    time_points, dipole_moment = fold(file_x, file_y, file_z)
    abs_imag = fourier(time_points, dipole_moment, pField_Transform_path)
    abs = absorption(abs_imag)

    fig = plt.figure(figsize=(14, 8))
    plt.plot(freq_eV, abs/max(abs), color='green', label='Spectrum')
    plt.xlabel('Angular frequency ω (eV)', fontsize=16)
    plt.ylabel('Absorption', fontsize=16)
    plt.title('Absorption Spectrum of Water', fontsize=20)
    plt.grid(True)
    plt.legend(fontsize=16)
    plt.tight_layout()
    plt.savefig(eV_spectrum_path, dpi=600)
    plt.show()

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/utils/gif.py
# utils/gif.py
import os
import logging
from PIL import Image

logger = logging.getLogger("main")

# run ulimit -n 4096 on linux first if this errors
def clear_directory(directory_path):
    try:
        files = os.listdir(directory_path)
        for file_name in files:
            file_path = os.path.join(directory_path, file_name)
            if os.path.isfile(file_path):
                os.remove(file_path)
                logging.debug(f"Deleted: {file_path}")
        logging.info(f"All files in {directory_path} have been deleted.")
    except Exception as e:
        logging.info(f"{e}, creating.")

def make_gif(frame_folder):
    frame_folder = os.path.basename(os.path.normpath(frame_folder))
    items = os.listdir(frame_folder)
    items = [file_name for file_name in items if file_name != ".DS_Store"]
    items = [item for item in items if "png" in item]
    sorted_items = sorted(items)
    os.chdir(frame_folder)
    frames = [Image.open(image) for image in sorted_items]
    frame_one = frames[0]
    frame_one.save(f"{frame_folder}.gif", format="GIF", append_images=frames[1:],
               save_all=True, duration=25, loop=0)
    logging.info(f"File Saved: {frame_folder}.gif")

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/utils/logging.py
# utils/logging.py
import logging

class PRINTLOGGER:
    """
    A custom logger to redirect stdout to the logging system.

    Captures print statements and logs them at a specified level.
    """
    def __init__(self, logger, level=logging.INFO):
        """
        Initialize the PRINTLOGGER with a logger and logging level.

        Parameters:
        logger : logging.Logger
            The logger object to use for logging messages.
        level : int, optional
            The logging level for captured messages (default logging.INFO).

        Returns:
        None
        """
        self.logger = logger
        self.level = level

    def write(self, message):
        """
        Write a message to the logger.

        Strips trailing newlines and logs non-empty messages.

        Parameters:
        message : str
            The message to log.

        Returns:
        None
        """
        message = message.rstrip()
        if message:
            self.logger.log(self.level, message)

    def flush(self):
        """
        Flush the logger output.

        Does nothing as logging handlers manage flushing.

        Parameters:
        None

        Returns:
        None
        """
        pass

// File: /Users/bldrdge1/Downloads/repos/PlasMol/src/utils/plotting.py
# utils/plotting.py
import logging
import pandas as pd
import matplotlib.pyplot as plt

logger = logging.getLogger("main")

def show_eField_pField(eFieldFileName, pFieldFileName=None, matplotlibLocationIMG=None, matplotlibOutput=None):
    """
    Plot electric field and optionally polarization field from CSV files.

    Generates a plot with one or two subplots depending on input, saving it to a file.

    Parameters:
    eFieldFileName : str
        Path to the electric field CSV file.
    pFieldFileName : str, optional
        Path to the polarization field CSV file (default None).
    matplotlibLocationIMG : str, optional
        Directory to save the plot image (default None).
    matplotlibOutput : str, optional
        Filename for the plot image (default None).

    Returns:
    None
    """
    logging.getLogger('matplotlib').setLevel(logging.INFO)

    if pFieldFileName is not None:
        logging.debug(f"Reading CSV files: {eFieldFileName} and {pFieldFileName}")
    else:
        logging.debug(f"Reading CSV file: {eFieldFileName}")

    def sort_csv_by_first_column(filename):
        """
        Sort a CSV file by its first column (timestamps).

        Preserves comments and header while sorting data rows.

        Parameters:
        filename : str
            Path to the CSV file to sort.

        Returns:
        None
        """
        with open(filename, 'r') as file:
            lines = file.readlines()
        comments = [line for line in lines if line.startswith('#')]
        header = next(line for line in lines if not line.startswith('#'))
        data_lines = [line for line in lines if not line.startswith('#') and line != header]
        from io import StringIO
        data = pd.read_csv(StringIO(''.join(data_lines)))
        timestamp_cols = [col for col in data.columns if col.startswith("Timestamps")]
        data_sorted = data.sort_values(by=timestamp_cols[0])
        with open(filename, 'w') as file:
            file.writelines(comments)
            file.write(header)
            data_sorted.to_csv(file, index=False)

    sort_csv_by_first_column(eFieldFileName)
    data1 = pd.read_csv(eFieldFileName, comment='#')
    timestamp_cols = [col for col in data1.columns if col.startswith("Timestamps")]
    data1 = data1.sort_values(by=timestamp_cols[0], ascending=True)
    timestamps1 = data1[timestamp_cols[0]]
    x_values1 = data1['X Values']
    y_values1 = data1['Y Values']
    z_values1 = data1['Z Values']

    if pFieldFileName is not None:
        sort_csv_by_first_column(pFieldFileName)
        data2 = pd.read_csv(pFieldFileName, comment='#')
        data2 = data2.sort_values(by=timestamp_cols[0], ascending=True)
        timestamps2 = data2[timestamp_cols[0]]
        x_values2 = data2['X Values']
        y_values2 = data2['Y Values']
        z_values2 = data2['Z Values']

        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))
        ax1.plot(timestamps1, x_values1, label='x', marker='o')
        ax1.plot(timestamps1, y_values1, label='y', marker='o')
        ax1.plot(timestamps1, z_values1, label='z', marker='o')
        ax1.set_title('Incident Electric Field')
        ax1.set_xlabel(timestamp_cols[0])
        ax1.set_ylabel('Electric Field Magnitude')
        ax1.legend()

        ax2.plot(timestamps2, x_values2, label='x', marker='o')
        ax2.plot(timestamps2, y_values2, label='y', marker='o')
        ax2.plot(timestamps2, z_values2, label='z', marker='o')
        ax2.set_title("Molecule's Response")
        ax2.set_xlabel(timestamp_cols[0])
        ax2.set_ylabel('Polarization Field Magnitude')
        ax2.legend()
    else:
        fig, ax1 = plt.subplots(figsize=(7, 5))
        ax1.plot(timestamps1, x_values1, label='x', marker='o')
        ax1.plot(timestamps1, y_values1, label='y', marker='o')
        ax1.plot(timestamps1, z_values1, label='z', marker='o')
        ax1.set_title('Incident Electric Field')
        ax1.set_xlabel(timestamp_cols[0])
        ax1.set_ylabel('Electric Field Magnitude')
        ax1.legend()

    plt.tight_layout()
    if matplotlibLocationIMG is None:
        if matplotlibOutput is None:
            plt.savefig('output.png', dpi=1000)
            logging.info("Matplotlib image written: output.png")
        else:
            plt.savefig(f'{matplotlibOutput}.png', dpi=1000)
            logging.info(f"Matplotlib image written: {matplotlibOutput}.png")
    elif matplotlibOutput is None:
        plt.savefig(f'{matplotlibLocationIMG}.png', dpi=1000)
        logging.info(f"Matplotlib image written: {matplotlibLocationIMG}.png")
    else:
        plt.savefig(f'{matplotlibLocationIMG}{matplotlibOutput}.png', dpi=1000)
        logging.info(f"Matplotlib image written: {matplotlibLocationIMG}{matplotlibOutput}.png")

